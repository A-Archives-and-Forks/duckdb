UnreservedKeyword <- 'ABORT'i /
'ABSOLUTE'i /
'ACCESS'i /
'ACTION'i /
'ADD'i /
'ADMIN'i /
'AFTER'i /
'AGGREGATE'i /
'ALSO'i /
'ALTER'i /
'ALWAYS'i /
'ASSERTION'i /
'ASSIGNMENT'i /
'ATTACH'i /
'ATTRIBUTE'i /
'BACKWARD'i /
'BEFORE'i /
'BEGIN'i /
'CACHE'i /
'CALL'i /
'CALLED'i /
'CASCADE'i /
'CASCADED'i /
'CATALOG'i /
'CENTURY'i /
'CENTURIES'i /
'CHAIN'i /
'CHARACTERISTICS'i /
'CHECKPOINT'i /
'CLASS'i /
'CLOSE'i /
'CLUSTER'i /
'COMMENT'i /
'COMMENTS'i /
'COMMIT'i /
'COMMITTED'i /
'COMPRESSION'i /
'CONFIGURATION'i /
'CONFLICT'i /
'CONNECTION'i /
'CONSTRAINTS'i /
'CONTENT'i /
'CONTINUE'i /
'CONVERSION'i /
'COPY'i /
'COST'i /
'CSV'i /
'CUBE'i /
'CURRENT'i /
'CURSOR'i /
'CYCLE'i /
'DATA'i /
'DATABASE'i /
'DAY'i /
'DAYS'i /
'DEALLOCATE'i /
'DECADE'i /
'DECADES'i /
'DECLARE'i /
'DEFAULTS'i /
'DEFERRED'i /
'DEFINER'i /
'DELETE'i /
'DELIMITER'i /
'DELIMITERS'i /
'DEPENDS'i /
'DETACH'i /
'DICTIONARY'i /
'DISABLE'i /
'DISCARD'i /
'DOCUMENT'i /
'DOMAIN'i /
'DOUBLE'i /
'DROP'i /
'EACH'i /
'ENABLE'i /
'ENCODING'i /
'ENCRYPTED'i /
'ENUM'i /
'ERROR'i /
'ESCAPE'i /
'EVENT'i /
'EXCLUDE'i /
'EXCLUDING'i /
'EXCLUSIVE'i /
'EXECUTE'i /
'EXPLAIN'i /
'EXPORT'i /
'EXPORT_STATE'i /
'EXTENSION'i /
'EXTENSIONS'i /
'EXTERNAL'i /
'FAMILY'i /
'FILTER'i /
'FIRST'i /
'FOLLOWING'i /
'FORCE'i /
'FORWARD'i /
'FUNCTION'i /
'FUNCTIONS'i /
'GLOBAL'i /
'GRANT'i /
'GRANTED'i /
'GROUPS'i /
'HANDLER'i /
'HEADER'i /
'HOLD'i /
'HOUR'i /
'HOURS'i /
'IDENTITY'i /
'IF'i /
'IGNORE'i /
'IMMEDIATE'i /
'IMMUTABLE'i /
'IMPLICIT'i /
'IMPORT'i /
'INCLUDE'i /
'INCLUDING'i /
'INCREMENT'i /
'INDEX'i /
'INDEXES'i /
'INHERIT'i /
'INHERITS'i /
'INLINE'i /
'INPUT'i /
'INSENSITIVE'i /
'INSERT'i /
'INSTALL'i /
'INSTEAD'i /
'INVOKER'i /
'JSON'i /
'ISOLATION'i /
'KEY'i /
'LABEL'i /
'LANGUAGE'i /
'LARGE'i /
'LAST'i /
'LEAKPROOF'i /
'LEVEL'i /
'LISTEN'i /
'LOAD'i /
'LOCAL'i /
'LOCATION'i /
'LOCK'i /
'LOCKED'i /
'LOGGED'i /
'MACRO'i /
'MAPPING'i /
'MATCH'i /
'MATCHED'i /
'MATERIALIZED'i /
'MAXVALUE'i /
'MERGE'i /
'METHOD'i /
'MICROSECOND'i /
'MICROSECONDS'i /
'MILLENNIUM'i /
'MILLENNIA'i /
'MILLISECOND'i /
'MILLISECONDS'i /
'MINUTE'i /
'MINUTES'i /
'MINVALUE'i /
'MODE'i /
'MONTH'i /
'MONTHS'i /
'MOVE'i /
'NAME'i /
'NAMES'i /
'NEW'i /
'NEXT'i /
'NO'i /
'NOTHING'i /
'NOTIFY'i /
'NOWAIT'i /
'NULLS'i /
'OBJECT'i /
'OF'i /
'OFF'i /
'OIDS'i /
'OLD'i /
'OPERATOR'i /
'OPTION'i /
'OPTIONS'i /
'ORDINALITY'i /
'OTHERS'i /
'OVER'i /
'OVERRIDING'i /
'OWNED'i /
'OWNER'i /
'PARALLEL'i /
'PARSER'i /
'PARTIAL'i /
'PARTITION'i /
'PARTITIONED'i /
'PASSING'i /
'PASSWORD'i /
'PERCENT'i /
'PERSISTENT'i /
'PLANS'i /
'POLICY'i /
'PRAGMA'i /
'PRECEDING'i /
'PREPARE'i /
'PREPARED'i /
'PRESERVE'i /
'PRIOR'i /
'PRIVILEGES'i /
'PROCEDURAL'i /
'PROCEDURE'i /
'PROGRAM'i /
'PUBLICATION'i /
'QUARTER'i /
'QUARTERS'i /
'QUOTE'i /
'RANGE'i /
'READ'i /
'REASSIGN'i /
'RECHECK'i /
'RECURSIVE'i /
'REF'i /
'REFERENCING'i /
'REFRESH'i /
'REINDEX'i /
'RELATIVE'i /
'RELEASE'i /
'RENAME'i /
'REPEATABLE'i /
'REPLACE'i /
'REPLICA'i /
'RESET'i /
'RESPECT'i /
'RESTART'i /
'RESTRICT'i /
'RETURNS'i /
'REVOKE'i /
'ROLE'i /
'ROLLBACK'i /
'ROLLUP'i /
'ROWS'i /
'RULE'i /
'SAMPLE'i /
'SAVEPOINT'i /
'SCHEMA'i /
'SCHEMAS'i /
'SCOPE'i /
'SCROLL'i /
'SEARCH'i /
'SECRET'i /
'SECOND'i /
'SECONDS'i /
'SECURITY'i /
'SEQUENCE'i /
'SEQUENCES'i /
'SERIALIZABLE'i /
'SERVER'i /
'SESSION'i /
'SET'i /
'SETS'i /
'SHARE'i /
'SIMPLE'i /
'SKIP'i /
'SNAPSHOT'i /
'SORTED'i /
'SOURCE'i /
'SQL'i /
'STABLE'i /
'STANDALONE'i /
'START'i /
'STATEMENT'i /
'STATISTICS'i /
'STDIN'i /
'STDOUT'i /
'STORAGE'i /
'STORED'i /
'STRICT'i /
'STRIP'i /
'SUBSCRIPTION'i /
'SYSID'i /
'SYSTEM'i /
'TABLES'i /
'TABLESPACE'i /
'TARGET'i /
'TEMP'i /
'TEMPLATE'i /
'TEMPORARY'i /
'TEXT'i /
'TIES'i /
'TRANSACTION'i /
'TRANSFORM'i /
'TRIGGER'i /
'TRUNCATE'i /
'TRUSTED'i /
'TYPE'i /
'TYPES'i /
'UNBOUNDED'i /
'UNCOMMITTED'i /
'UNENCRYPTED'i /
'UNKNOWN'i /
'UNLISTEN'i /
'UNLOGGED'i /
'UNTIL'i /
'UPDATE'i /
'USE'i /
'USER'i /
'VACUUM'i /
'VALID'i /
'VALIDATE'i /
'VALIDATOR'i /
'VALUE'i /
'VARIABLE'i /
'VARYING'i /
'VERSION'i /
'VIEW'i /
'VIEWS'i /
'VIRTUAL'i /
'VOLATILE'i /
'WEEK'i /
'WEEKS'i /
'WHITESPACE'i /
'WITHIN'i /
'WITHOUT'i /
'WORK'i /
'WRAPPER'i /
'WRITE'i /
'XML'i /
'YEAR'i /
'YEARS'i /
'YES'i /
'ZONE'i
ReservedKeyword <- 'ALL'i /
'ANALYSE'i /
'ANALYZE'i /
'AND'i /
'ANY'i /
'ARRAY'i /
'AS'i /
'ASC'i /
'ASYMMETRIC'i /
'BOTH'i /
'CASE'i /
'CAST'i /
'CHECK'i /
'COLLATE'i /
'COLUMN'i /
'CONSTRAINT'i /
'CREATE'i /
'DEFAULT'i /
'DEFERRABLE'i /
'DESC'i /
'DESCRIBE'i /
'DISTINCT'i /
'DO'i /
'ELSE'i /
'END'i /
'EXCEPT'i /
'FALSE'i /
'FETCH'i /
'FOR'i /
'FOREIGN'i /
'FROM'i /
'GROUP'i /
'HAVING'i /
'QUALIFY'i /
'IN'i /
'INITIALLY'i /
'INTERSECT'i /
'INTO'i /
'LAMBDA'i /
'LATERAL'i /
'LEADING'i /
'LIMIT'i /
'NOT'i /
'NULL'i /
'OFFSET'i /
'ON'i /
'ONLY'i /
'OR'i /
'ORDER'i /
'PIVOT'i /
'PIVOT_WIDER'i /
'PIVOT_LONGER'i /
'PLACING'i /
'PRIMARY'i /
'REFERENCES'i /
'RETURNING'i /
'SELECT'i /
'SHOW'i /
'SOME'i /
'SUMMARIZE'i /
'SYMMETRIC'i /
'TABLE'i /
'THEN'i /
'TO'i /
'TRAILING'i /
'TRUE'i /
'UNION'i /
'UNIQUE'i /
'UNPIVOT'i /
'USING'i /
'VARIADIC'i /
'WHEN'i /
'WHERE'i /
'WINDOW'i /
'WITH'i
ColumnNameKeyword <- 'BETWEEN'i /
'BIGINT'i /
'BIT'i /
'BOOLEAN'i /
'CHAR'i /
'CHARACTER'i /
'COALESCE'i /
'COLUMNS'i /
'DEC'i /
'DECIMAL'i /
'EXISTS'i /
'EXTRACT'i /
'FLOAT'i /
'GENERATED'i /
'GROUPING'i /
'GROUPING_ID'i /
'INOUT'i /
'INT'i /
'INTEGER'i /
'INTERVAL'i /
'MAP'i /
'NATIONAL'i /
'NCHAR'i /
'NONE'i /
'NULLIF'i /
'NUMERIC'i /
'OUT'i /
'OVERLAY'i /
'POSITION'i /
'PRECISION'i /
'REAL'i /
'ROW'i /
'SETOF'i /
'SMALLINT'i /
'SUBSTRING'i /
'STRUCT'i /
'TIME'i /
'TIMESTAMP'i /
'TREAT'i /
'TRIM'i /
'TRY_CAST'i /
'VALUES'i /
'VARCHAR'i /
'XMLATTRIBUTES'i /
'XMLCONCAT'i /
'XMLELEMENT'i /
'XMLEXISTS'i /
'XMLFOREST'i /
'XMLNAMESPACES'i /
'XMLPARSE'i /
'XMLPI'i /
'XMLROOT'i /
'XMLSERIALIZE'i /
'XMLTABLE'i
FuncNameKeyword <- 'ASOF'i /
'AT'i /
'AUTHORIZATION'i /
'BINARY'i /
'COLLATION'i /
'CONCURRENTLY'i /
'CROSS'i /
'FREEZE'i /
'FULL'i /
'GENERATED'i /
'GLOB'i /
'ILIKE'i /
'INNER'i /
'IS'i /
'ISNULL'i /
'JOIN'i /
'LEFT'i /
'LIKE'i /
'MAP'i /
'NATURAL'i /
'NOTNULL'i /
'OUTER'i /
'OVERLAPS'i /
'POSITIONAL'i /
'RIGHT'i /
'SIMILAR'i /
'STRUCT'i /
'TABLESAMPLE'i /
'VERBOSE'i
TypeNameKeyword <- 'ASOF'i /
'AT'i /
'AUTHORIZATION'i /
'BINARY'i /
'BY'i /
'COLLATION'i /
'COLUMNS'i /
'CONCURRENTLY'i /
'CROSS'i /
'FREEZE'i /
'FULL'i /
'GLOB'i /
'ILIKE'i /
'INNER'i /
'IS'i /
'ISNULL'i /
'JOIN'i /
'LEFT'i /
'LIKE'i /
'NATURAL'i /
'NOTNULL'i /
'OUTER'i /
'OVERLAPS'i /
'POSITIONAL'i /
'RIGHT'i /
'UNPACK'i /
'SIMILAR'i /
'TABLESAMPLE'i /
'TRY_CAST'i /
'VERBOSE'i /
'SEMI'i /
'ANTI'i
PivotStatement <- PivotKeyword TableRef PivotOn? PivotUsing? GroupByClause?

PivotOn <- 'ON' PivotColumnList
PivotUsing <- 'USING' TargetList

PivotColumnList <- List(Expression)

PivotKeyword <- 'PIVOT' / 'PIVOT_WIDER'
UnpivotKeyword <- 'UNPIVOT' / 'PIVOT_LONGER'

UnpivotStatement <- UnpivotKeyword TableRef 'ON' TargetList IntoNameValues?

IntoNameValues <- 'NTO' 'NAME' ColIdOrString ValueOrValues List(Identifier)

ValueOrValues <- 'VALUE' / 'VALUES'

IncludeExcludeNulls <- ('NCLUDE' / 'EXCLUDE') 'NULLS'
UnpivotHeader <- ColIdOrString / Parens(List(ColIdOrString))

ColumnReference <- CatalogReservedSchemaTableColumnName / SchemaReservedTableColumnName / TableReservedColumnName / ColumnName
CatalogReservedSchemaTableColumnName <- CatalogQualification ReservedSchemaQualification ReservedTableQualification ReservedColumnName
SchemaReservedTableColumnName <- SchemaQualification ReservedTableQualification ReservedColumnName
TableReservedColumnName <- TableQualification ReservedColumnName
FunctionExpression <- FunctionIdentifier Parens(DistinctOrAll? List(FunctionArgument)? OrderByClause? IgnoreNulls?) WithinGroupClause? FilterClause? ExportClause? OverClause?

FunctionIdentifier <- CatalogReservedSchemaFunctionName / SchemaReservedFunctionName / FunctionName
CatalogReservedSchemaFunctionName <- CatalogQualification ReservedSchemaQualification? ReservedFunctionName
SchemaReservedFunctionName <- SchemaQualification ReservedFunctionName

DistinctOrAll <- 'DISTINCT' / 'ALL'
ExportClause <- 'EXPORT_STATE'
WithinGroupClause <- 'WITHIN' 'GROUP' Parens(OrderByClause)
FilterClause <- 'FILTER' Parens('WHERE'? Expression)
IgnoreNulls <- ('GNORE' 'NULLS') / ('RESPECT' 'NULLS')

ParenthesisExpression <- Parens(List(Expression))
LiteralExpression <- StringLiteral / NumberLiteral / 'NULL' / 'TRUE' / 'FALSE'
CastExpression <- CastOrTryCast Parens(Expression 'AS' Type)
CastOrTryCast <- 'CAST' / 'TRY_CAST'

StarExpression <- (ColId '.')* '*' ExcludeList? ReplaceList? RenameList?
ExcludeList <- 'EXCLUDE' (Parens(List(ExcludeName)) / ExcludeName)
ExcludeName <- DottedIdentifier / ColIdOrString
ReplaceList <- 'REPLACE' (Parens(List(ReplaceEntry)) / ReplaceEntry)
ReplaceEntry <- Expression 'AS' ColumnReference
RenameList <- 'RENAME' (Parens(List(RenameEntry)) / RenameEntry)
RenameEntry <- ColumnReference 'AS' Identifier
SubqueryExpression <- 'NOT'? 'EXISTS'? SubqueryReference
CaseExpression <- 'CASE' Expression? CaseWhenThen CaseWhenThen* CaseElse? 'END'
CaseWhenThen <- 'WHEN' Expression 'THEN' Expression
CaseElse <- 'ELSE' Expression
TypeLiteral <- ColId StringLiteral
IntervalLiteral <- 'NTERVAL' IntervalParameter IntervalUnit?
IntervalParameter <- StringLiteral / NumberLiteral / Parens(Expression)
IntervalUnit <- ColId
FrameClause <- Framing FrameExtent WindowExcludeClause?
Framing <- 'ROWS' / 'RANGE' / 'GROUPS'
FrameExtent <- ('BETWEEN' FrameBound 'AND' FrameBound) / FrameBound
FrameBound <- ('UNBOUNDED' 'PRECEDING') / ('UNBOUNDED' 'FOLLOWING') / ('CURRENT' 'ROW') / (Expression 'PRECEDING') / (Expression 'FOLLOWING')
WindowExcludeClause <- 'EXCLUDE' WindowExcludeElement
WindowExcludeElement <- ('CURRENT' 'ROW') / 'GROUP' / 'TIES' / ('NO' 'OTHERS')
OverClause <- 'OVER' WindowFrame
WindowFrame <- WindowFrameDefinition / Identifier / Parens(Identifier)
WindowFrameDefinition <- Parens(BaseWindowName? WindowFrameContents) / Parens(WindowFrameContents)
WindowFrameContents <- WindowPartition? OrderByClause? FrameClause?
BaseWindowName <- Identifier
WindowPartition <- 'PARTITION' 'BY' List(Expression)
PrefixExpression <- PrefixOperator Expression
PrefixOperator <- 'NOT' / '-' / '+' / '~'
ListExpression <- 'ARRAY'? (BoundedListExpression / SelectStatement)
BoundedListExpression <- '[' List(Expression)? ']'
StructExpression <- '{' List(StructField)? '}'
StructField <- Expression ':' Expression
MapExpression <- 'MAP' StructExpression
GroupingExpression <- GroupingOrGroupingId Parens(List(Expression))
GroupingOrGroupingId <- 'GROUPING' / 'GROUPING_ID'
Parameter <- '?' / NumberedParameter / ColLabelParameter
NumberedParameter <- '$' NumberLiteral
ColLabelParameter <- '$' ColLabel
PositionalExpression <- '#' NumberLiteral
DefaultExpression <- 'DEFAULT'

ListComprehensionExpression <- '[' Expression 'FOR' List(Expression) ListComprehensionFilter? ']'
ListComprehensionFilter <- 'F' Expression

SingleExpression <-
	LiteralExpression /
	Parameter /
    SubqueryExpression /
    SpecialFunctionExpression /
    ParenthesisExpression /
    IntervalLiteral /
    TypeLiteral /
    CaseExpression /
    StarExpression /
    CastExpression /
    GroupingExpression /
    MapExpression /
    FunctionExpression /
    ColumnReference /
    PrefixExpression /
    ListComprehensionExpression /
    ListExpression /
    StructExpression /
    PositionalExpression /
    DefaultExpression



OperatorLiteral <- <[\+\-\*\/\%\^\<\>\=\~\!\@\&\|\`]+>
LikeOperator <- 'NOT'? LikeOrSimilarTo
LikeOrSimilarTo <- 'LIKE' / 'LIKE' / 'GLOB' / ('SIMILAR' 'TO')
InOperator <- 'NOT'? 'N'
IsOperator <- 'S' 'NOT'? DistinctFrom?
DistinctFrom <- 'DISTINCT' 'FROM'
ConjunctionOperator <- 'OR' / 'AND'
ComparisonOperator <- '=' / '<=' / '>=' / '<' / '>' / '<>' / '!=' / '=='
BetweenOperator <- 'NOT'? 'BETWEEN'
CollateOperator <- 'COLLATE'
LambdaOperator <- '->'
EscapeOperator <- 'ESCAPE'
AtTimeZoneOperator <- 'AT' 'TIME' 'ZONE'
PostfixOperator <- '!'
AnyAllOperator <- ComparisonOperator AnyOrAll
AnyOrAll <- 'ANY' / 'ALL'

Operator <-
	AnyAllOperator /
    ConjunctionOperator /
    LikeOperator /
    InOperator /
    IsOperator /
    BetweenOperator /
    CollateOperator /
    LambdaOperator /
    EscapeOperator /
    AtTimeZoneOperator /
    OperatorLiteral

CastOperator <- '::' Type
DotOperator <- '.' (FunctionExpression / ColLabel)
NotNull <- 'NOT' 'NULL'
Indirection <- CastOperator / DotOperator / SliceExpression / NotNull / PostfixOperator

BaseExpression <- SingleExpression Indirection*
Expression <- BaseExpression RecursiveExpression*
RecursiveExpression <- (Operator Expression)
SliceExpression <- '[' SliceBound ']'
SliceBound <- Expression? (':' (Expression / '-')?)? (':' Expression?)?

SpecialFunctionExpression <- CoalesceExpression / UnpackExpression / ColumnsExpression / ExtractExpression / LambdaExpression / NullIfExpression / PositionExpression / RowExpression / SubstringExpression / TrimExpression
CoalesceExpression <- 'COALESCE' Parens(List(Expression))
UnpackExpression <- 'UNPACK' Parens(Expression)
ColumnsExpression <- '*'? 'COLUMNS' Parens(Expression)
ExtractExpression <- 'EXTRACT' Parens(Expression 'FROM' Expression)
LambdaExpression <- 'LAMBDA' List(ColIdOrString) ':' Expression
NullIfExpression <- 'NULLIF' Parens(Expression ',' Expression)
PositionExpression <- 'POSITION' Parens(Expression)
RowExpression <- 'ROW' Parens(List(Expression))
SubstringExpression <- 'SUBSTRING' Parens(SubstringParameters / List(Expression))
SubstringParameters <- Expression 'FROM' NumberLiteral 'FOR' NumberLiteral
TrimExpression <- 'TRIM' Parens(TrimDirection? TrimSource? List(Expression))

TrimDirection <- 'BOTH' / 'LEADING' / 'TRAILING'
TrimSource <- Expression? 'FROM'

ExecuteStatement <- 'EXECUTE' Identifier TableFunctionArguments?
CreateSecretStmt <- 'SECRET' IfNotExists? SecretName? SecretStorageSpecifier? Parens(GenericCopyOptionList)

SecretStorageSpecifier <- 'IN' Identifier

CreateViewStmt <- 'RECURSIVE'? 'VIEW' IfNotExists? QualifiedName InsertColumnList? 'AS' SelectStatement

DescribeStatement <- ShowSelect / ShowAllTables / ShowQualifiedName

ShowSelect <- ShowOrDescribeOrSummarize SelectStatement
ShowAllTables <- ShowOrDescribe 'ALL' 'TABLES'
ShowQualifiedName <- ShowOrDescribeOrSummarize (BaseTableName / StringLiteral)?

ShowOrDescribeOrSummarize <- ShowOrDescribe / 'SUMMARIZE'
ShowOrDescribe <- 'SHOW' / 'DESCRIBE' / 'DESC'

VacuumStatement <- 'VACUUM' (VacuumLegacyOptions AnalyzeStatement / VacuumLegacyOptions QualifiedTarget / VacuumLegacyOptions / VacuumParensOptions QualifiedTarget?)?

VacuumLegacyOptions <- OptFull OptFreeze OptVerbose
VacuumParensOptions <- Parens(List(VacuumOption))
VacuumOption <- 'ANALYZE' / 'VERBOSE' / 'FREEZE' / 'FULL' / Identifier

OptFull <- 'FULL'?
OptFreeze <- 'FREEZE'?
OptVerbose <- 'VERBOSE'?

QualifiedTarget <- QualifiedName OptNameList
OptNameList <- Parens(List(Name))?
MergeIntoStatement <- WithClause? 'MERGE' 'NTO' TargetOptAlias MergeIntoUsingClause MergeMatch* ReturningClause?
MergeIntoUsingClause <- 'USING' TableRef JoinQualifier
MergeMatch <- MatchedClause / NotMatchedClause
MatchedClause <- 'WHEN' 'MATCHED' AndExpression? 'THEN' MatchedClauseAction
MatchedClauseAction <- UpdateMatchClause / DeleteMatchClause / InsertMatchClause / DoNothingMatchClause / ErrorMatchClause
UpdateMatchClause <- 'UPDATE' (UpdateMatchSetClause / ByNameOrPosition?)
DeleteMatchClause <- 'DELETE'
InsertMatchClause <- 'NSERT' (InsertValuesList / DefaultValues / InsertByNameOrPosition)?
InsertByNameOrPosition <- ByNameOrPosition? '*'?
InsertValuesList <- InsertColumnList? 'VALUES' Parens(List(Expression))
DoNothingMatchClause <- 'DO' 'NOTHING'
ErrorMatchClause <- 'ERROR' Expression?
UpdateMatchSetClause <- 'SET' (UpdateSetClause / '*')
AndExpression <- 'AND' Expression
NotMatchedClause <- 'WHEN' 'NOT' 'MATCHED' BySourceOrTarget? AndExpression? 'THEN' MatchedClauseAction
BySourceOrTarget <- 'BY' ('SOURCE' / 'TARGET')






PragmaStatement <- 'PRAGMA' (PragmaAssign / PragmaFunction)

PragmaAssign <- SettingName '=' VariableList
PragmaFunction <- PragmaName PragmaParameters?
PragmaParameters <- List(Expression)

DeallocateStatement <- 'DEALLOCATE' 'PREPARE'? Identifier

PrepareStatement <- 'PREPARE' Identifier TypeList? 'AS' Statement

TypeList <- Parens(List(Type))

CreateStatement <- 'CREATE' OrReplace? Temporary? (CreateTableStmt / CreateMacroStmt / CreateSequenceStmt / CreateTypeStmt / CreateSchemaStmt / CreateViewStmt / CreateIndexStmt / CreateSecretStmt)
OrReplace <- 'OR' 'REPLACE'
Temporary <- 'TEMP' / 'TEMPORARY' / 'PERSISTENT'

CreateTableStmt <- 'TABLE' IfNotExists? QualifiedName (CreateTableAs / CreateColumnList) CommitAction?

CreateTableAs <- IdentifierList? 'AS' SelectStatement WithData?
WithData <- 'WITH' 'NO'? 'DATA'
IdentifierList <- Parens(List(Identifier))
CreateColumnList <- Parens(CreateTableColumnList)
IfNotExists <- 'F' 'NOT' 'EXISTS'
QualifiedName <- CatalogReservedSchemaIdentifier / SchemaReservedIdentifierOrStringLiteral / IdentifierOrStringLiteral
SchemaReservedIdentifierOrStringLiteral <- SchemaQualification ReservedIdentifierOrStringLiteral
CatalogReservedSchemaIdentifier <- CatalogQualification ReservedSchemaQualification ReservedIdentifierOrStringLiteral
IdentifierOrStringLiteral <- Identifier / StringLiteral
ReservedIdentifierOrStringLiteral <- ReservedIdentifier / StringLiteral
CatalogQualification <- CatalogName '.'
SchemaQualification <- SchemaName '.'
ReservedSchemaQualification <- ReservedSchemaName '.'
TableQualification <- TableName '.'
ReservedTableQualification <- ReservedTableName '.'

CreateTableColumnList <- List(CreateTableColumnElement)
CreateTableColumnElement <- ColumnDefinition / TopLevelConstraint
ColumnDefinition <- DottedIdentifier TypeOrGenerated ColumnConstraint*
TypeOrGenerated <- Type? GeneratedColumn?
ColumnConstraint <- NotNullConstraint / UniqueConstraint / PrimaryKeyConstraint / DefaultValue / CheckConstraint / ForeignKeyConstraint / ColumnCollation / ColumnCompression
NotNullConstraint <- 'NOT'? 'NULL'
UniqueConstraint <- 'UNIQUE'
PrimaryKeyConstraint <- 'PRIMARY' 'KEY'
DefaultValue <- 'DEFAULT' Expression
CheckConstraint <- 'CHECK' Parens(Expression)
ForeignKeyConstraint <- 'REFERENCES' BaseTableName Parens(ColumnList)? KeyActions?
ColumnCollation <- 'COLLATE' Expression
ColumnCompression <- 'USING' 'COMPRESSION' ColIdOrString

KeyActions <- UpdateAction? DeleteAction?
UpdateAction <- 'ON' 'UPDATE' KeyAction
DeleteAction <- 'ON' 'DELETE' KeyAction
KeyAction <- ('NO' 'ACTION') / 'RESTRICT' / 'CASCADE' / ('SET' 'NULL') / ('SET' 'DEFAULT')

TopLevelConstraint <- ConstraintNameClause? TopLevelConstraintList
TopLevelConstraintList <- TopPrimaryKeyConstraint / CheckConstraint / TopUniqueConstraint / TopForeignKeyConstraint
ConstraintNameClause <- 'CONSTRAINT' Identifier
TopPrimaryKeyConstraint <- 'PRIMARY' 'KEY' ColumnIdList
TopUniqueConstraint <- 'UNIQUE' ColumnIdList
TopForeignKeyConstraint <- 'FOREIGN' 'KEY' ColumnIdList ForeignKeyConstraint
ColumnIdList <- Parens(List(ColId))

PlainIdentifier <- !ReservedKeyword <[a-z_]i[a-z0-9_]i*>
QuotedIdentifier <- '"' [^"]* '"'
DottedIdentifier <- Identifier ('.' Identifier)*
Identifier <- QuotedIdentifier / PlainIdentifier

ColId <- UnreservedKeyword / ColumnNameKeyword / Identifier
ColIdOrString <- ColId / StringLiteral
FuncName <- UnreservedKeyword / FuncNameKeyword / Identifier
TypeFuncName <- UnreservedKeyword / TypeNameKeyword / FuncNameKeyword / Identifier
TypeName <- UnreservedKeyword / TypeNameKeyword / Identifier
ColLabel <- ReservedKeyword / UnreservedKeyword / ColumnNameKeyword / FuncNameKeyword / TypeNameKeyword / Identifier
ColLabelOrString <- ColLabel / StringLiteral
GeneratedColumn <- Generated? 'AS' Parens(Expression) GeneratedColumnType?

Generated <- 'GENERATED' AlwaysOrByDefault?
AlwaysOrByDefault <- 'ALWAYS' / ('BY' 'DEFAULT')
GeneratedColumnType <- 'VIRTUAL' / 'STORED'

CommitAction <- 'ON' 'COMMIT' 'PRESERVE' 'ROWS'

CreateIndexStmt <- Unique? 'NDEX' IfNotExists? IndexName? 'ON' BaseTableName IndexType? Parens(List(IndexElement)) WithList?

WithList <- 'WITH' Parens(List(RelOption)) / Oids
Oids <- ('WITH' / 'WITHOUT') 'OIDS'
IndexElement <- Expression DescOrAsc? NullsFirstOrLast?
Unique <- 'UNIQUE'
IndexType <- 'USING' Identifier
RelOption <- ColLabel ('.' ColLabel)* ('=' DefArg)?
DefArg <- FuncType / ReservedKeyword / StringLiteral / NumberLiteral / 'NONE'
FuncType <- Type / ('SETOF'? TypeFuncName '%' 'TYPE')

LoadStatement <- 'LOAD' ColIdOrString
InstallStatement <- 'FORCE'? 'NSTALL' Identifier FromSource? VersionNumber?
FromSource <- 'FROM' (Identifier / StringLiteral)
VersionNumber <- Identifier
DropStatement <- 'DROP' DropEntries DropBehavior?

DropEntries <-
	DropTable /
	DropTableFunction /
	DropFunction /
	DropSchema /
	DropIndex /
	DropSequence /
	DropCollation /
	DropType /
	DropSecret

DropTable <- TableOrView IfExists? List(BaseTableName)
DropTableFunction <- 'MACRO' 'TABLE' IfExists? List(TableFunctionName)
DropFunction <- FunctionType IfExists? List(FunctionIdentifier)
DropSchema <- 'SCHEMA' IfExists? List(QualifiedSchemaName)
DropIndex <- 'NDEX' IfExists? List(QualifiedIndexName)
QualifiedIndexName <- CatalogQualification? SchemaQualification? IndexName
DropSequence <- 'SEQUENCE' IfExists? List(QualifiedSequenceName)
DropCollation <- 'COLLATION' IfExists? List(CollationName)
DropType <- 'TYPE' IfExists? List(QualifiedTypeName)
DropSecret <- Temporary? 'SECRET' IfExists? SecretName DropSecretStorage?

TableOrView <- 'TABLE' / 'VIEW' / ('MATERIALIZED' 'VIEW')
FunctionType <- 'MACRO' / 'FUNCTION'

DropBehavior <- 'CASCADE' / 'RESTRICT'

IfExists <- 'F' 'EXISTS'
QualifiedSchemaName <- CatalogQualification? SchemaName

DropSecretStorage <- 'FROM' Identifier

UpdateStatement <- WithClause? 'UPDATE' UpdateTarget UpdateSetClause FromClause? WhereClause? ReturningClause?

UpdateTarget <- (BaseTableName 'SET') / (BaseTableName UpdateAlias? 'SET')
UpdateAlias <- 'AS'? ColId
UpdateSetClause <- List(UpdateSetElement) / (Parens(List(ColumnName)) '=' Expression)
UpdateSetElement <- ColumnName '=' Expression

InsertStatement <- WithClause? 'NSERT' OrAction? 'NTO' InsertTarget ByNameOrPosition? InsertColumnList? InsertValues OnConflictClause? ReturningClause?

OrAction <- 'OR' 'REPLACE' / 'GNORE'
ByNameOrPosition <- 'BY' 'NAME' / 'POSITION'

InsertTarget <- BaseTableName InsertAlias?
InsertAlias <- 'AS' Identifier

ColumnList <- List(ColId)
InsertColumnList <- Parens(ColumnList)

InsertValues <- SelectStatement / DefaultValues
DefaultValues <- 'DEFAULT' 'VALUES'

OnConflictClause <- 'ON' 'CONFLICT' OnConflictTarget? OnConflictAction

OnConflictTarget <- OnConflictExpressionTarget / OnConflictIndexTarget
OnConflictExpressionTarget <- Parens(List(ColId)) WhereClause?
OnConflictIndexTarget <- 'ON' 'CONSTRAINT' ConstraintName


OnConflictAction <- OnConflictUpdate / OnConflictNothing

OnConflictUpdate <- 'DO' 'UPDATE' 'SET' UpdateSetClause WhereClause?
OnConflictNothing <- 'DO' 'NOTHING'

ReturningClause <- 'RETURNING' TargetList

CreateSchemaStmt <- 'SCHEMA' IfNotExists? QualifiedName
SelectStatement <- SelectOrParens (SetopClause SelectStatement)* ResultModifiers

SetopClause <- ('UNION' / 'EXCEPT' / 'NTERSECT') DistinctOrAll? ByName?
ByName <- 'BY' 'NAME'
SelectOrParens <- BaseSelect / Parens(SelectStatement)

BaseSelect <- WithClause? (OptionalParensSimpleSelect / ValuesClause / DescribeStatement / TableStatement / PivotStatement / UnpivotStatement) ResultModifiers
ResultModifiers <- OrderByClause? LimitClause? OffsetClause?
TableStatement <- 'TABLE' BaseTableName
OptionalParensSimpleSelect <- Parens(SimpleSelect) / SimpleSelect
SimpleSelect <- SelectFrom WhereClause? GroupByClause? HavingClause? WindowClause? QualifyClause? SampleClause?

SelectFrom <- (SelectClause FromClause?) / (FromClause SelectClause?)
WithStatement <- ColIdOrString InsertColumnList? UsingKey? 'AS' Materialized? SubqueryReference
UsingKey <- 'USING' 'KEY' Parens(List(ColId))
Materialized <- 'NOT'? 'MATERIALIZED'
WithClause <- 'WITH' Recursive? List(WithStatement)
Recursive <- 'RECURSIVE'
SelectClause <- 'SELECT' DistinctClause? TargetList
TargetList <- List(AliasedExpression)
ColumnAliases <- Parens(List(ColIdOrString))

DistinctClause <- ('DISTINCT' DistinctOn?) / 'ALL'
DistinctOn <- 'ON' Parens(List(Expression))

InnerTableRef <- ValuesRef / TableFunction / TableSubquery / BaseTableRef / ParensTableRef

TableRef <- InnerTableRef JoinOrPivot* TableAlias?
TableSubquery <- Lateral? SubqueryReference TableAlias?
BaseTableRef <- TableAliasColon? BaseTableName TableAlias? AtClause?
TableAliasColon <- ColIdOrString ':'
ValuesRef <- ValuesClause TableAlias?
ParensTableRef <- TableAliasColon? Parens(TableRef)

JoinOrPivot <- JoinClause / TablePivotClause / TableUnpivotClause

TablePivotClause <- 'PIVOT' Parens(TargetList 'FOR' PivotValueLists GroupByClause?) TableAlias?
TableUnpivotClause <- 'UNPIVOT' IncludeExcludeNulls? Parens(UnpivotHeader 'FOR' PivotValueLists) TableAlias?

PivotHeader <- BaseExpression
PivotValueLists <- PivotValueList PivotValueList*
PivotValueList <- PivotHeader 'N' PivotTargetList
PivotTargetList <- Identifier / Parens(TargetList)

Lateral <- 'LATERAL'

BaseTableName <- CatalogReservedSchemaTable / SchemaReservedTable / TableName
SchemaReservedTable <- SchemaQualification ReservedTableName
CatalogReservedSchemaTable <- CatalogQualification ReservedSchemaQualification ReservedTableName

TableFunction <- TableFunctionLateralOpt / TableFunctionAliasColon
TableFunctionLateralOpt <- Lateral? QualifiedTableFunction TableFunctionArguments TableAlias?
TableFunctionAliasColon <- TableAliasColon QualifiedTableFunction TableFunctionArguments
QualifiedTableFunction <- CatalogQualification? SchemaQualification? TableFunctionName
TableFunctionArguments <- Parens(List(FunctionArgument)?)
FunctionArgument <- NamedParameter / Expression
NamedParameter <- TypeName NamedParameterAssignment Expression
NamedParameterAssignment <- ':=' / '=>'

TableAlias <- 'AS'? (Identifier / StringLiteral) ColumnAliases?

AtClause <- 'AT' Parens(AtSpecifier)
AtSpecifier <- AtUnit '=>' Expression
AtUnit <- 'VERSION' / 'TIMESTAMP'

JoinClause <- RegularJoinClause / JoinWithoutOnClause
RegularJoinClause <- 'ASOF'? JoinType? 'JOIN' TableRef JoinQualifier
JoinWithoutOnClause <- JoinPrefix 'JOIN' TableRef
JoinQualifier <- OnClause / UsingClause
OnClause <- 'ON' Expression
UsingClause <- 'USING' Parens(List(ColumnName))

OuterJoinType <- 'FULL' / 'LEFT' / 'RIGHT'
JoinType <- (OuterJoinType 'OUTER'?) / 'SEMI' / 'ANTI' / 'NNER'
JoinPrefix <- 'CROSS' / ('NATURAL' JoinType?) / 'POSITIONAL'

FromClause <- 'FROM' List(TableRef)
WhereClause <- 'WHERE' Expression
GroupByClause <- 'GROUP' 'BY' GroupByExpressions
HavingClause <- 'HAVING' Expression
QualifyClause <- 'QUALIFY' Expression
SampleClause <- (TableSample / UsingSample) SampleEntry
UsingSample <- 'USING' 'SAMPLE'
TableSample <- 'TABLESAMPLE'
WindowClause <- 'WINDOW' List(WindowDefinition)
WindowDefinition <- Identifier 'AS' WindowFrameDefinition

SampleEntry <- SampleEntryFunction / SampleEntryCount
SampleEntryCount <- SampleCount Parens(SampleProperties)?
SampleEntryFunction <- SampleFunction? Parens(SampleCount) RepeatableSample?
SampleFunction <- ColId
SampleProperties <- ColId (',' NumberLiteral)?
RepeatableSample <- 'REPEATABLE' Parens(NumberLiteral)

SampleCount <- Expression SampleUnit?
SampleUnit <- '%' / 'PERCENT' / 'ROWS'

GroupByExpressions <- GroupByList / 'ALL'
GroupByList <- List(GroupByExpression)
GroupByExpression <- EmptyGroupingItem / CubeOrRollupClause / GroupingSetsClause / Expression
EmptyGroupingItem <- '(' ')'
CubeOrRollupClause <- CubeOrRollup Parens(List(Expression))
CubeOrRollup <- 'CUBE' / 'ROLLUP'
GroupingSetsClause <- 'GROUPING' 'SETS' Parens(GroupByList)

SubqueryReference <- Parens(SelectStatement)

OrderByExpression <- Expression DescOrAsc? NullsFirstOrLast?
DescOrAsc <- 'DESC' / 'DESCENDING' / 'ASC' / 'ASCENDING'
NullsFirstOrLast <- 'NULLS' 'FIRST' / 'LAST'
OrderByClause <- 'ORDER' 'BY' OrderByExpressions
OrderByExpressions <- List(OrderByExpression) / OrderByAll
OrderByAll <- 'ALL' DescOrAsc? NullsFirstOrLast?

LimitClause <- 'LIMIT' LimitValue
OffsetClause <- 'OFFSET' LimitValue
LimitValue <- 'ALL' / (NumberLiteral 'PERCENT') / (Expression '%'?)

AliasedExpression <- (ColId ':' Expression) / (Expression 'AS' ColLabelOrString) / (Expression Identifier?)

ValuesClause <- 'VALUES' List(ValuesExpressions)
ValuesExpressions <- Parens(List(Expression))

TransactionStatement <- BeginTransaction / RollbackTransaction / CommitTransaction

BeginTransaction <- StartOrBegin Transaction? ReadOrWrite?
RollbackTransaction <- AbortOrRollback Transaction?
CommitTransaction <- CommitOrEnd Transaction?

StartOrBegin <- 'START' / 'BEGIN'
Transaction <- 'WORK' / 'TRANSACTION'
ReadOrWrite <- 'READ' ('ONLY' / 'WRITE')
AbortOrRollback <- 'ABORT' / 'ROLLBACK'
CommitOrEnd <- 'COMMIT' / 'END'

DeleteStatement <- WithClause? 'DELETE' 'FROM' TargetOptAlias DeleteUsingClause? WhereClause? ReturningClause?
TruncateStatement <- 'TRUNCATE' 'TABLE'? BaseTableName
TargetOptAlias <- BaseTableName 'AS'? ColId?
DeleteUsingClause <- 'USING' List(TableRef)

CreateTypeStmt <- 'TYPE' IfNotExists? QualifiedName 'AS' CreateType
CreateType <- ('ENUM' Parens(SelectStatement)) /
              ('ENUM' Parens(List(StringLiteral))) /
              Type

SetStatement <- 'SET' (StandardAssignment / SetTimeZone)

StandardAssignment <- (SetVariable / SetSetting) SetAssignment
SetTimeZone <- 'TIME' 'ZONE' Expression
SetSetting <- SettingScope? SettingName
SetVariable <- 'VARIABLE' Identifier

SettingScope <- 'LOCAL' / 'SESSION' / 'GLOBAL'

SetAssignment <- VariableAssign VariableList

VariableAssign <- '=' / 'TO'
VariableList <- List(Expression)

ResetStatement <- 'RESET' (SetVariable / SetSetting)

ExportStatement <- 'EXPORT' 'DATABASE' ExportSource? StringLiteral Parens(GenericCopyOptionList)?

ExportSource <- CatalogName 'TO'

ImportStatement <- 'MPORT' 'DATABASE' StringLiteral

CheckpointStatement <- 'FORCE'? 'CHECKPOINT' CatalogName?

CopyStatement <- 'COPY' (CopyTable / CopySelect / CopyFromDatabase)

CopyTable <- BaseTableName InsertColumnList? FromOrTo CopyFileName CopyOptions?
FromOrTo <- 'FROM' / 'TO'

CopySelect <- Parens(SelectStatement) 'TO' CopyFileName CopyOptions?

CopyFileName <- StringLiteral / Identifier / (Identifier '.' ColId)
CopyOptions <- 'WITH'? (Parens(GenericCopyOptionList) / (SpecializedOptions*))
SpecializedOptions <-
	'BINARY' / 'FREEZE' / 'OIDS' / 'CSV' / 'HEADER' /
	SpecializedStringOption /
	('ENCODING' StringLiteral) /
	('FORCE' 'QUOTE' StarOrColumnList) /
	('PARTITION' 'BY' StarOrColumnList) /
	('FORCE' 'NOT'? 'NULL' ColumnList)

SpecializedStringOption <- ('DELIMITER' / 'NULL' / 'QUOTE' / 'ESCAPE') 'AS'? StringLiteral

StarOrColumnList <- '*' / ColumnList

GenericCopyOptionList <- List(GenericCopyOption)
GenericCopyOption <- GenericCopyOptionName Expression?
# FIXME: should not need to hard-code options here
GenericCopyOptionName <- 'ARRAY' / 'NULL' / 'ANALYZE' / CopyOptionName

CopyFromDatabase <- 'FROM' 'DATABASE' ColId 'TO' ColId CopyDatabaseFlag?

CopyDatabaseFlag <- Parens(SchemaOrData)
SchemaOrData <- 'SCHEMA' / 'DATA'

AlterStatement <- 'ALTER' AlterOptions


AlterOptions <- AlterTableStmt / AlterViewStmt / AlterSequenceStmt

AlterTableStmt <- 'TABLE' IfExists? BaseTableName AlterTableOptions

AlterTableOptions <- AddColumn / DropColumn / AlterColumn / AddConstraint / ChangeNullability / RenameColumn / RenameAlter / SetPartitionedBy / ResetPartitionedBy / SetSortedBy / ResetSortedBy

AddConstraint <- 'ADD' TopLevelConstraint
AddColumn <- 'ADD' 'COLUMN'? IfNotExists? ColumnDefinition
DropColumn <- 'DROP' 'COLUMN'? IfExists? NestedColumnName DropBehavior?
AlterColumn <- 'ALTER' 'COLUMN'? NestedColumnName AlterColumnEntry
RenameColumn <- 'RENAME' 'COLUMN'? NestedColumnName 'TO' Identifier
NestedColumnName <- (Identifier '.')* ColumnName
RenameAlter <- 'RENAME' 'TO' Identifier
SetPartitionedBy <- 'SET' 'PARTITIONED' 'BY' Parens(List(Expression))
ResetPartitionedBy <- 'RESET' 'PARTITIONED' 'BY'
SetSortedBy <- 'SET' 'SORTED' 'BY' OrderByExpressions
ResetSortedBy <- 'RESET' 'SORTED' 'BY'

AlterColumnEntry <- AddOrDropDefault / ChangeNullability / AlterType

AddOrDropDefault <- AddDefault / DropDefault
AddDefault <- 'SET' 'DEFAULT' Expression
DropDefault <- 'DROP' 'DEFAULT'

ChangeNullability <- ('DROP' / 'SET') 'NOT' 'NULL'

AlterType <- SetData? 'TYPE' Type? UsingExpression?
SetData <- 'SET' 'DATA'?
UsingExpression <- 'USING' Expression

AlterViewStmt <- 'VIEW' IfExists? BaseTableName RenameAlter

AlterSequenceStmt <- 'SEQUENCE' IfExists? QualifiedSequenceName AlterSequenceOptions

QualifiedSequenceName <- CatalogQualification? SchemaQualification? SequenceName

AlterSequenceOptions <- RenameAlter / SetSequenceOption
SetSequenceOption <- List(SequenceOption)

CreateSequenceStmt <- 'SEQUENCE' IfNotExists? QualifiedName SequenceOption*

SequenceOption <-
	SeqSetCycle /
	SeqSetIncrement /
	SeqSetMinMax /
	SeqNoMinMax /
	SeqStartWith /
	SeqOwnedBy

SeqSetCycle <- 'NO'? 'CYCLE'
SeqSetIncrement <- 'NCREMENT' 'BY'? Expression
SeqSetMinMax <- SeqMinOrMax Expression
SeqNoMinMax <- 'NO' SeqMinOrMax
SeqStartWith <- 'START' 'WITH'? Expression
SeqOwnedBy <- 'OWNED' 'BY' QualifiedName


SeqMinOrMax <- 'MINVALUE' / 'MAXVALUE'


Statement <-
	CreateStatement /
	SelectStatement /
	SetStatement /
	PragmaStatement /
	CallStatement /
	InsertStatement /
	DropStatement /
	CopyStatement /
	ExplainStatement /
	UpdateStatement /
	PrepareStatement /
	ExecuteStatement /
	AlterStatement /
	TransactionStatement /
	DeleteStatement /
	AttachStatement /
	UseStatement /
	DetachStatement /
	CheckpointStatement /
	VacuumStatement /
	ResetStatement /
	ExportStatement /
	ImportStatement /
	CommentStatement /
	DeallocateStatement /
	TruncateStatement /
	LoadStatement /
	InstallStatement /
	AnalyzeStatement /
	MergeIntoStatement

CatalogName <- Identifier
SchemaName <- Identifier
ReservedSchemaName <- Identifier
TableName <- Identifier
ReservedTableName <- Identifier
ReservedIdentifier <- Identifier
ColumnName <- Identifier
ReservedColumnName <- Identifier
IndexName <- Identifier
SettingName <- Identifier
PragmaName <- Identifier
FunctionName <- Identifier
ReservedFunctionName <- Identifier
TableFunctionName <- Identifier
ConstraintName <- ColIdOrString
SequenceName <- Identifier
CollationName <- Identifier
CopyOptionName <- ColLabel
SecretName <- ColId

NumberLiteral <- < [+-]?[0-9]*([.][0-9]*)? >
StringLiteral <- '\'' [^\']* '\''

Type <- (TimeType / IntervalType / BitType / RowType / MapType / UnionType / NumericType / SimpleType) ArrayBounds*
SimpleType <- (QualifiedTypeName / CharacterType) TypeModifiers?
CharacterType <- ('CHARACTER' 'VARYING'?) /
                 ('CHAR' 'VARYING'?) /
                 ('NATIONAL' 'CHARACTER' 'VARYING'?) /
                 ('NATIONAL' 'CHAR' 'VARYING'?) /
                 ('NCHAR' 'VARYING'?) /
                 'VARCHAR'
IntervalType <- ('NTERVAL' Interval?) / ('NTERVAL' Parens(NumberLiteral))

YearKeyword         <- 'YEAR' / 'YEARS'
MonthKeyword        <- 'MONTH' / 'MONTHS'
DayKeyword          <- 'DAY' / 'DAYS'
HourKeyword         <- 'HOUR' / 'HOURS'
MinuteKeyword       <- 'MINUTE' / 'MINUTES'
SecondKeyword       <- 'SECOND' / 'SECONDS'
MillisecondKeyword  <- 'MILLISECOND' / 'MILLISECONDS'
MicrosecondKeyword  <- 'MICROSECOND' / 'MICROSECONDS'
WeekKeyword         <- 'WEEK' / 'WEEKS'
QuarterKeyword      <- 'QUARTER' / 'QUARTERS'
DecadeKeyword       <- 'DECADE' / 'DECADES'
CenturyKeyword      <- 'CENTURY' / 'CENTURIES'
MillenniumKeyword   <- 'MILLENNIUM' / 'MILLENNIA'

Interval <- YearKeyword /
    MonthKeyword /
    DayKeyword /
    HourKeyword /
    MinuteKeyword /
    SecondKeyword /
    MillisecondKeyword /
    MicrosecondKeyword /
    WeekKeyword /
    QuarterKeyword /
    DecadeKeyword /
    CenturyKeyword /
    MillenniumKeyword /
    (YearKeyword 'TO' MonthKeyword) /
    (DayKeyword 'TO' HourKeyword) /
    (DayKeyword 'TO' MinuteKeyword) /
    (DayKeyword 'TO' SecondKeyword) /
    (HourKeyword 'TO' MinuteKeyword) /
    (HourKeyword 'TO' SecondKeyword) /
    (MinuteKeyword 'TO' SecondKeyword)

BitType <- 'BIT' 'VARYING'? Parens(List(Expression))?

NumericType <- 'NT' /
               'NTEGER' /
               'SMALLINT' /
               'BIGINT' /
               'REAL' /
               'BOOLEAN' /
               ('FLOAT' Parens(NumberLiteral)?) /
               ('DOUBLE' 'PRECISION') /
               ('DECIMAL' TypeModifiers?) /
               ('DEC' TypeModifiers?) /
               ('NUMERIC' TypeModifiers?)

QualifiedTypeName <- CatalogQualification? SchemaQualification? TypeName
TypeModifiers <- Parens(List(Expression)?)
RowType <- RowOrStruct Parens(List(ColIdType))
UnionType <- 'UNION' Parens(List(ColIdType))
MapType <- 'MAP' Parens(List(Type))
ColIdType <- ColId Type
ArrayBounds <- ('[' NumberLiteral? ']') / 'ARRAY'
TimeType <- TimeOrTimestamp TypeModifiers? TimeZone?
TimeOrTimestamp <- 'TIME' / 'TIMESTAMP'
TimeZone <- WithOrWithout 'TIME' 'ZONE'
WithOrWithout <- 'WITH' / 'WITHOUT'

RowOrStruct <- 'ROW' / 'STRUCT'

# internal definitions
%whitespace <- [ \t\n\r]*
List(D) <- D (',' D)* ','?
Parens(D) <- '(' D ')'

ExplainStatement <- 'EXPLAIN' 'ANALYZE'? ExplainOptions? Statement

ExplainOptions <- Parens(GenericCopyOptionList)

AnalyzeStatement <- 'ANALYZE' 'VERBOSE'? AnalyzeTarget?
AnalyzeTarget <- QualifiedName Parens(List(Name))?
Name <- ColId ('.' ColLabel)*
CreateMacroStmt <- MacroOrFunction IfNotExists? QualifiedName List(MacroDefinition)

MacroOrFunction <- 'MACRO' / 'FUNCTION'

MacroDefinition <- Parens(MacroParameters?) 'AS' (TableMacroDefinition / ScalarMacroDefinition)

MacroParameters <- List(MacroParameter)
MacroParameter <- NamedParameter / TypeFuncName

ScalarMacroDefinition <- Expression
TableMacroDefinition <- 'TABLE' SelectStatement

CommentStatement <- 'COMMENT' 'ON' CommentOnType ColumnReference 'S' CommentValue


CommentOnType <- 'TABLE' / 'SEQUENCE' / 'FUNCTION' / ('MACRO' 'TABLE'?) / 'VIEW' / 'DATABASE' / 'NDEX' / 'SCHEMA' / 'TYPE' / 'COLUMN'
CommentValue <- 'NULL' / StringLiteral

AttachStatement <- 'ATTACH' OrReplace? IfNotExists? Database? DatabasePath AttachAlias? AttachOptions?

Database <- 'DATABASE'
DatabasePath <- StringLiteral
AttachAlias <- 'AS' ColId
AttachOptions <- Parens(GenericCopyOptionList)

DetachStatement <- 'DETACH' Database? IfExists? CatalogName

UseStatement <- 'USE' UseTarget

UseTarget <- (CatalogName '.' ReservedSchemaName) / SchemaName / CatalogName

CallStatement <- 'CALL' TableFunctionName TableFunctionArguments

