/* THIS FILE WAS AUTOMATICALLY GENERATED BY inline_grammar.py */
#pragma once

namespace duckdb {

const char INLINED_PEG_GRAMMAR[] = {
	"UnreservedKeyword <- 'ABORT'i /\n"
	"'ABSOLUTE'i /\n"
	"'ACCESS'i /\n"
	"'ACTION'i /\n"
	"'ADD'i /\n"
	"'ADMIN'i /\n"
	"'AFTER'i /\n"
	"'AGGREGATE'i /\n"
	"'ALSO'i /\n"
	"'ALTER'i /\n"
	"'ALWAYS'i /\n"
	"'ASSERTION'i /\n"
	"'ASSIGNMENT'i /\n"
	"'ATTACH'i /\n"
	"'ATTRIBUTE'i /\n"
	"'BACKWARD'i /\n"
	"'BEFORE'i /\n"
	"'BEGIN'i /\n"
	"'CACHE'i /\n"
	"'CALL'i /\n"
	"'CALLED'i /\n"
	"'CASCADE'i /\n"
	"'CASCADED'i /\n"
	"'CATALOG'i /\n"
	"'CENTURY'i /\n"
	"'CENTURIES'i /\n"
	"'CHAIN'i /\n"
	"'CHARACTERISTICS'i /\n"
	"'CHECKPOINT'i /\n"
	"'CLASS'i /\n"
	"'CLOSE'i /\n"
	"'CLUSTER'i /\n"
	"'COMMENT'i /\n"
	"'COMMENTS'i /\n"
	"'COMMIT'i /\n"
	"'COMMITTED'i /\n"
	"'COMPRESSION'i /\n"
	"'CONFIGURATION'i /\n"
	"'CONFLICT'i /\n"
	"'CONNECTION'i /\n"
	"'CONSTRAINTS'i /\n"
	"'CONTENT'i /\n"
	"'CONTINUE'i /\n"
	"'CONVERSION'i /\n"
	"'COPY'i /\n"
	"'COST'i /\n"
	"'CSV'i /\n"
	"'CUBE'i /\n"
	"'CURRENT'i /\n"
	"'CURSOR'i /\n"
	"'CYCLE'i /\n"
	"'DATA'i /\n"
	"'DATABASE'i /\n"
	"'DAY'i /\n"
	"'DAYS'i /\n"
	"'DEALLOCATE'i /\n"
	"'DECADE'i /\n"
	"'DECADES'i /\n"
	"'DECLARE'i /\n"
	"'DEFAULTS'i /\n"
	"'DEFERRED'i /\n"
	"'DEFINER'i /\n"
	"'DELETE'i /\n"
	"'DELIMITER'i /\n"
	"'DELIMITERS'i /\n"
	"'DEPENDS'i /\n"
	"'DETACH'i /\n"
	"'DICTIONARY'i /\n"
	"'DISABLE'i /\n"
	"'DISCARD'i /\n"
	"'DOCUMENT'i /\n"
	"'DOMAIN'i /\n"
	"'DOUBLE'i /\n"
	"'DROP'i /\n"
	"'EACH'i /\n"
	"'ENABLE'i /\n"
	"'ENCODING'i /\n"
	"'ENCRYPTED'i /\n"
	"'ENUM'i /\n"
	"'ERROR'i /\n"
	"'ESCAPE'i /\n"
	"'EVENT'i /\n"
	"'EXCLUDE'i /\n"
	"'EXCLUDING'i /\n"
	"'EXCLUSIVE'i /\n"
	"'EXECUTE'i /\n"
	"'EXPLAIN'i /\n"
	"'EXPORT'i /\n"
	"'EXPORT_STATE'i /\n"
	"'EXTENSION'i /\n"
	"'EXTENSIONS'i /\n"
	"'EXTERNAL'i /\n"
	"'FAMILY'i /\n"
	"'FILTER'i /\n"
	"'FIRST'i /\n"
	"'FOLLOWING'i /\n"
	"'FORCE'i /\n"
	"'FORWARD'i /\n"
	"'FUNCTION'i /\n"
	"'FUNCTIONS'i /\n"
	"'GLOBAL'i /\n"
	"'GRANT'i /\n"
	"'GRANTED'i /\n"
	"'GROUPS'i /\n"
	"'HANDLER'i /\n"
	"'HEADER'i /\n"
	"'HOLD'i /\n"
	"'HOUR'i /\n"
	"'HOURS'i /\n"
	"'IDENTITY'i /\n"
	"'IF'i /\n"
	"'IGNORE'i /\n"
	"'IMMEDIATE'i /\n"
	"'IMMUTABLE'i /\n"
	"'IMPLICIT'i /\n"
	"'IMPORT'i /\n"
	"'INCLUDE'i /\n"
	"'INCLUDING'i /\n"
	"'INCREMENT'i /\n"
	"'INDEX'i /\n"
	"'INDEXES'i /\n"
	"'INHERIT'i /\n"
	"'INHERITS'i /\n"
	"'INLINE'i /\n"
	"'INPUT'i /\n"
	"'INSENSITIVE'i /\n"
	"'INSERT'i /\n"
	"'INSTALL'i /\n"
	"'INSTEAD'i /\n"
	"'INVOKER'i /\n"
	"'JSON'i /\n"
	"'ISOLATION'i /\n"
	"'KEY'i /\n"
	"'LABEL'i /\n"
	"'LANGUAGE'i /\n"
	"'LARGE'i /\n"
	"'LAST'i /\n"
	"'LEAKPROOF'i /\n"
	"'LEVEL'i /\n"
	"'LISTEN'i /\n"
	"'LOAD'i /\n"
	"'LOCAL'i /\n"
	"'LOCATION'i /\n"
	"'LOCK'i /\n"
	"'LOCKED'i /\n"
	"'LOGGED'i /\n"
	"'MACRO'i /\n"
	"'MAPPING'i /\n"
	"'MATCH'i /\n"
	"'MATCHED'i /\n"
	"'MATERIALIZED'i /\n"
	"'MAXVALUE'i /\n"
	"'MERGE'i /\n"
	"'METHOD'i /\n"
	"'MICROSECOND'i /\n"
	"'MICROSECONDS'i /\n"
	"'MILLENNIUM'i /\n"
	"'MILLENNIA'i /\n"
	"'MILLISECOND'i /\n"
	"'MILLISECONDS'i /\n"
	"'MINUTE'i /\n"
	"'MINUTES'i /\n"
	"'MINVALUE'i /\n"
	"'MODE'i /\n"
	"'MONTH'i /\n"
	"'MONTHS'i /\n"
	"'MOVE'i /\n"
	"'NAME'i /\n"
	"'NAMES'i /\n"
	"'NEW'i /\n"
	"'NEXT'i /\n"
	"'NO'i /\n"
	"'NOTHING'i /\n"
	"'NOTIFY'i /\n"
	"'NOWAIT'i /\n"
	"'NULLS'i /\n"
	"'OBJECT'i /\n"
	"'OF'i /\n"
	"'OFF'i /\n"
	"'OIDS'i /\n"
	"'OLD'i /\n"
	"'OPERATOR'i /\n"
	"'OPTION'i /\n"
	"'OPTIONS'i /\n"
	"'ORDINALITY'i /\n"
	"'OTHERS'i /\n"
	"'OVER'i /\n"
	"'OVERRIDING'i /\n"
	"'OWNED'i /\n"
	"'OWNER'i /\n"
	"'PARALLEL'i /\n"
	"'PARSER'i /\n"
	"'PARTIAL'i /\n"
	"'PARTITION'i /\n"
	"'PARTITIONED'i /\n"
	"'PASSING'i /\n"
	"'PASSWORD'i /\n"
	"'PERCENT'i /\n"
	"'PERSISTENT'i /\n"
	"'PLANS'i /\n"
	"'POLICY'i /\n"
	"'PRAGMA'i /\n"
	"'PRECEDING'i /\n"
	"'PREPARE'i /\n"
	"'PREPARED'i /\n"
	"'PRESERVE'i /\n"
	"'PRIOR'i /\n"
	"'PRIVILEGES'i /\n"
	"'PROCEDURAL'i /\n"
	"'PROCEDURE'i /\n"
	"'PROGRAM'i /\n"
	"'PUBLICATION'i /\n"
	"'QUARTER'i /\n"
	"'QUARTERS'i /\n"
	"'QUOTE'i /\n"
	"'RANGE'i /\n"
	"'READ'i /\n"
	"'REASSIGN'i /\n"
	"'RECHECK'i /\n"
	"'RECURSIVE'i /\n"
	"'REF'i /\n"
	"'REFERENCING'i /\n"
	"'REFRESH'i /\n"
	"'REINDEX'i /\n"
	"'RELATIVE'i /\n"
	"'RELEASE'i /\n"
	"'RENAME'i /\n"
	"'REPEATABLE'i /\n"
	"'REPLACE'i /\n"
	"'REPLICA'i /\n"
	"'RESET'i /\n"
	"'RESPECT'i /\n"
	"'RESTART'i /\n"
	"'RESTRICT'i /\n"
	"'RETURNS'i /\n"
	"'REVOKE'i /\n"
	"'ROLE'i /\n"
	"'ROLLBACK'i /\n"
	"'ROLLUP'i /\n"
	"'ROWS'i /\n"
	"'RULE'i /\n"
	"'SAMPLE'i /\n"
	"'SAVEPOINT'i /\n"
	"'SCHEMA'i /\n"
	"'SCHEMAS'i /\n"
	"'SCOPE'i /\n"
	"'SCROLL'i /\n"
	"'SEARCH'i /\n"
	"'SECRET'i /\n"
	"'SECOND'i /\n"
	"'SECONDS'i /\n"
	"'SECURITY'i /\n"
	"'SEQUENCE'i /\n"
	"'SEQUENCES'i /\n"
	"'SERIALIZABLE'i /\n"
	"'SERVER'i /\n"
	"'SESSION'i /\n"
	"'SET'i /\n"
	"'SETS'i /\n"
	"'SHARE'i /\n"
	"'SIMPLE'i /\n"
	"'SKIP'i /\n"
	"'SNAPSHOT'i /\n"
	"'SORTED'i /\n"
	"'SOURCE'i /\n"
	"'SQL'i /\n"
	"'STABLE'i /\n"
	"'STANDALONE'i /\n"
	"'START'i /\n"
	"'STATEMENT'i /\n"
	"'STATISTICS'i /\n"
	"'STDIN'i /\n"
	"'STDOUT'i /\n"
	"'STORAGE'i /\n"
	"'STORED'i /\n"
	"'STRICT'i /\n"
	"'STRIP'i /\n"
	"'SUBSCRIPTION'i /\n"
	"'SYSID'i /\n"
	"'SYSTEM'i /\n"
	"'TABLES'i /\n"
	"'TABLESPACE'i /\n"
	"'TARGET'i /\n"
	"'TEMP'i /\n"
	"'TEMPLATE'i /\n"
	"'TEMPORARY'i /\n"
	"'TEXT'i /\n"
	"'TIES'i /\n"
	"'TRANSACTION'i /\n"
	"'TRANSFORM'i /\n"
	"'TRIGGER'i /\n"
	"'TRUNCATE'i /\n"
	"'TRUSTED'i /\n"
	"'TYPE'i /\n"
	"'TYPES'i /\n"
	"'UNBOUNDED'i /\n"
	"'UNCOMMITTED'i /\n"
	"'UNENCRYPTED'i /\n"
	"'UNKNOWN'i /\n"
	"'UNLISTEN'i /\n"
	"'UNLOGGED'i /\n"
	"'UNTIL'i /\n"
	"'UPDATE'i /\n"
	"'USE'i /\n"
	"'USER'i /\n"
	"'VACUUM'i /\n"
	"'VALID'i /\n"
	"'VALIDATE'i /\n"
	"'VALIDATOR'i /\n"
	"'VALUE'i /\n"
	"'VARIABLE'i /\n"
	"'VARYING'i /\n"
	"'VERSION'i /\n"
	"'VIEW'i /\n"
	"'VIEWS'i /\n"
	"'VIRTUAL'i /\n"
	"'VOLATILE'i /\n"
	"'WEEK'i /\n"
	"'WEEKS'i /\n"
	"'WHITESPACE'i /\n"
	"'WITHIN'i /\n"
	"'WITHOUT'i /\n"
	"'WORK'i /\n"
	"'WRAPPER'i /\n"
	"'WRITE'i /\n"
	"'XML'i /\n"
	"'YEAR'i /\n"
	"'YEARS'i /\n"
	"'YES'i /\n"
	"'ZONE'i\n"
	"ReservedKeyword <- 'ALL'i /\n"
	"'ANALYSE'i /\n"
	"'ANALYZE'i /\n"
	"'AND'i /\n"
	"'ANY'i /\n"
	"'ARRAY'i /\n"
	"'AS'i /\n"
	"'ASC'i /\n"
	"'ASYMMETRIC'i /\n"
	"'BOTH'i /\n"
	"'CASE'i /\n"
	"'CAST'i /\n"
	"'CHECK'i /\n"
	"'COLLATE'i /\n"
	"'COLUMN'i /\n"
	"'CONSTRAINT'i /\n"
	"'CREATE'i /\n"
	"'DEFAULT'i /\n"
	"'DEFERRABLE'i /\n"
	"'DESC'i /\n"
	"'DESCRIBE'i /\n"
	"'DISTINCT'i /\n"
	"'DO'i /\n"
	"'ELSE'i /\n"
	"'END'i /\n"
	"'EXCEPT'i /\n"
	"'FALSE'i /\n"
	"'FETCH'i /\n"
	"'FOR'i /\n"
	"'FOREIGN'i /\n"
	"'FROM'i /\n"
	"'GROUP'i /\n"
	"'HAVING'i /\n"
	"'QUALIFY'i /\n"
	"'IN'i /\n"
	"'INITIALLY'i /\n"
	"'INTERSECT'i /\n"
	"'INTO'i /\n"
	"'LAMBDA'i /\n"
	"'LATERAL'i /\n"
	"'LEADING'i /\n"
	"'LIMIT'i /\n"
	"'NOT'i /\n"
	"'NULL'i /\n"
	"'OFFSET'i /\n"
	"'ON'i /\n"
	"'ONLY'i /\n"
	"'OR'i /\n"
	"'ORDER'i /\n"
	"'PIVOT'i /\n"
	"'PIVOT_WIDER'i /\n"
	"'PIVOT_LONGER'i /\n"
	"'PLACING'i /\n"
	"'PRIMARY'i /\n"
	"'REFERENCES'i /\n"
	"'RETURNING'i /\n"
	"'SELECT'i /\n"
	"'SHOW'i /\n"
	"'SOME'i /\n"
	"'SUMMARIZE'i /\n"
	"'SYMMETRIC'i /\n"
	"'TABLE'i /\n"
	"'THEN'i /\n"
	"'TO'i /\n"
	"'TRAILING'i /\n"
	"'TRUE'i /\n"
	"'UNION'i /\n"
	"'UNIQUE'i /\n"
	"'UNPIVOT'i /\n"
	"'USING'i /\n"
	"'VARIADIC'i /\n"
	"'WHEN'i /\n"
	"'WHERE'i /\n"
	"'WINDOW'i /\n"
	"'WITH'i\n"
	"ColumnNameKeyword <- 'BETWEEN'i /\n"
	"'BIGINT'i /\n"
	"'BIT'i /\n"
	"'BOOLEAN'i /\n"
	"'CHAR'i /\n"
	"'CHARACTER'i /\n"
	"'COALESCE'i /\n"
	"'COLUMNS'i /\n"
	"'DEC'i /\n"
	"'DECIMAL'i /\n"
	"'EXISTS'i /\n"
	"'EXTRACT'i /\n"
	"'FLOAT'i /\n"
	"'GENERATED'i /\n"
	"'GROUPING'i /\n"
	"'GROUPING_ID'i /\n"
	"'INOUT'i /\n"
	"'INT'i /\n"
	"'INTEGER'i /\n"
	"'INTERVAL'i /\n"
	"'MAP'i /\n"
	"'NATIONAL'i /\n"
	"'NCHAR'i /\n"
	"'NONE'i /\n"
	"'NULLIF'i /\n"
	"'NUMERIC'i /\n"
	"'OUT'i /\n"
	"'OVERLAY'i /\n"
	"'POSITION'i /\n"
	"'PRECISION'i /\n"
	"'REAL'i /\n"
	"'ROW'i /\n"
	"'SETOF'i /\n"
	"'SMALLINT'i /\n"
	"'SUBSTRING'i /\n"
	"'STRUCT'i /\n"
	"'TIME'i /\n"
	"'TIMESTAMP'i /\n"
	"'TREAT'i /\n"
	"'TRIM'i /\n"
	"'TRY_CAST'i /\n"
	"'VALUES'i /\n"
	"'VARCHAR'i /\n"
	"'XMLATTRIBUTES'i /\n"
	"'XMLCONCAT'i /\n"
	"'XMLELEMENT'i /\n"
	"'XMLEXISTS'i /\n"
	"'XMLFOREST'i /\n"
	"'XMLNAMESPACES'i /\n"
	"'XMLPARSE'i /\n"
	"'XMLPI'i /\n"
	"'XMLROOT'i /\n"
	"'XMLSERIALIZE'i /\n"
	"'XMLTABLE'i\n"
	"FuncNameKeyword <- 'ASOF'i /\n"
	"'AT'i /\n"
	"'AUTHORIZATION'i /\n"
	"'BINARY'i /\n"
	"'COLLATION'i /\n"
	"'CONCURRENTLY'i /\n"
	"'CROSS'i /\n"
	"'FREEZE'i /\n"
	"'FULL'i /\n"
	"'GENERATED'i /\n"
	"'GLOB'i /\n"
	"'ILIKE'i /\n"
	"'INNER'i /\n"
	"'IS'i /\n"
	"'ISNULL'i /\n"
	"'JOIN'i /\n"
	"'LEFT'i /\n"
	"'LIKE'i /\n"
	"'MAP'i /\n"
	"'NATURAL'i /\n"
	"'NOTNULL'i /\n"
	"'OUTER'i /\n"
	"'OVERLAPS'i /\n"
	"'POSITIONAL'i /\n"
	"'RIGHT'i /\n"
	"'SIMILAR'i /\n"
	"'STRUCT'i /\n"
	"'TABLESAMPLE'i /\n"
	"'VERBOSE'i\n"
	"TypeNameKeyword <- 'ASOF'i /\n"
	"'AT'i /\n"
	"'AUTHORIZATION'i /\n"
	"'BINARY'i /\n"
	"'BY'i /\n"
	"'COLLATION'i /\n"
	"'COLUMNS'i /\n"
	"'CONCURRENTLY'i /\n"
	"'CROSS'i /\n"
	"'FREEZE'i /\n"
	"'FULL'i /\n"
	"'GLOB'i /\n"
	"'ILIKE'i /\n"
	"'INNER'i /\n"
	"'IS'i /\n"
	"'ISNULL'i /\n"
	"'JOIN'i /\n"
	"'LEFT'i /\n"
	"'LIKE'i /\n"
	"'NATURAL'i /\n"
	"'NOTNULL'i /\n"
	"'OUTER'i /\n"
	"'OVERLAPS'i /\n"
	"'POSITIONAL'i /\n"
	"'RIGHT'i /\n"
	"'UNPACK'i /\n"
	"'SIMILAR'i /\n"
	"'TABLESAMPLE'i /\n"
	"'TRY_CAST'i /\n"
	"'VERBOSE'i /\n"
	"'SEMI'i /\n"
	"'ANTI'i\n"
	"PivotStatement <- PivotKeyword TableRef PivotOn? PivotUsing? GroupByClause?\n"
	"PivotOn <- 'ON' PivotColumnList\n"
	"PivotUsing <- 'USING' TargetList\n"
	"PivotColumnList <- List(Expression)\n"
	"PivotKeyword <- 'PIVOT' / 'PIVOT_WIDER'\n"
	"UnpivotKeyword <- 'UNPIVOT' / 'PIVOT_LONGER'\n"
	"UnpivotStatement <- UnpivotKeyword TableRef 'ON' TargetList IntoNameValues?\n"
	"IntoNameValues <- 'NTO' 'NAME' ColIdOrString ValueOrValues List(Identifier)\n"
	"ValueOrValues <- 'VALUE' / 'VALUES'\n"
	"IncludeExcludeNulls <- ('NCLUDE' / 'EXCLUDE') 'NULLS'\n"
	"UnpivotHeader <- ColIdOrString / Parens(List(ColIdOrString))\n"
	"ColumnReference <- CatalogReservedSchemaTableColumnName / SchemaReservedTableColumnName / TableReservedColumnName / ColumnName\n"
	"CatalogReservedSchemaTableColumnName <- CatalogQualification ReservedSchemaQualification ReservedTableQualification ReservedColumnName\n"
	"SchemaReservedTableColumnName <- SchemaQualification ReservedTableQualification ReservedColumnName\n"
	"TableReservedColumnName <- TableQualification ReservedColumnName\n"
	"FunctionExpression <- FunctionIdentifier Parens(DistinctOrAll? List(FunctionArgument)? OrderByClause? IgnoreNulls?) WithinGroupClause? FilterClause? ExportClause? OverClause?\n"
	"FunctionIdentifier <- CatalogReservedSchemaFunctionName / SchemaReservedFunctionName / FunctionName\n"
	"CatalogReservedSchemaFunctionName <- CatalogQualification ReservedSchemaQualification? ReservedFunctionName\n"
	"SchemaReservedFunctionName <- SchemaQualification ReservedFunctionName\n"
	"DistinctOrAll <- 'DISTINCT' / 'ALL'\n"
	"ExportClause <- 'EXPORT_STATE'\n"
	"WithinGroupClause <- 'WITHIN' 'GROUP' Parens(OrderByClause)\n"
	"FilterClause <- 'FILTER' Parens('WHERE'? Expression)\n"
	"IgnoreNulls <- ('GNORE' 'NULLS') / ('RESPECT' 'NULLS')\n"
	"ParenthesisExpression <- Parens(List(Expression))\n"
	"LiteralExpression <- StringLiteral / NumberLiteral / 'NULL' / 'TRUE' / 'FALSE'\n"
	"CastExpression <- CastOrTryCast Parens(Expression 'AS' Type)\n"
	"CastOrTryCast <- 'CAST' / 'TRY_CAST'\n"
	"StarExpression <- (ColId '.')* '*' ExcludeList? ReplaceList? RenameList?\n"
	"ExcludeList <- 'EXCLUDE' (Parens(List(ExcludeName)) / ExcludeName)\n"
	"ExcludeName <- DottedIdentifier / ColIdOrString\n"
	"ReplaceList <- 'REPLACE' (Parens(List(ReplaceEntry)) / ReplaceEntry)\n"
	"ReplaceEntry <- Expression 'AS' ColumnReference\n"
	"RenameList <- 'RENAME' (Parens(List(RenameEntry)) / RenameEntry)\n"
	"RenameEntry <- ColumnReference 'AS' Identifier\n"
	"SubqueryExpression <- 'NOT'? 'EXISTS'? SubqueryReference\n"
	"CaseExpression <- 'CASE' Expression? CaseWhenThen CaseWhenThen* CaseElse? 'END'\n"
	"CaseWhenThen <- 'WHEN' Expression 'THEN' Expression\n"
	"CaseElse <- 'ELSE' Expression\n"
	"TypeLiteral <- ColId StringLiteral\n"
	"IntervalLiteral <- 'NTERVAL' IntervalParameter IntervalUnit?\n"
	"IntervalParameter <- StringLiteral / NumberLiteral / Parens(Expression)\n"
	"IntervalUnit <- ColId\n"
	"FrameClause <- Framing FrameExtent WindowExcludeClause?\n"
	"Framing <- 'ROWS' / 'RANGE' / 'GROUPS'\n"
	"FrameExtent <- ('BETWEEN' FrameBound 'AND' FrameBound) / FrameBound\n"
	"FrameBound <- ('UNBOUNDED' 'PRECEDING') / ('UNBOUNDED' 'FOLLOWING') / ('CURRENT' 'ROW') / (Expression 'PRECEDING') / (Expression 'FOLLOWING')\n"
	"WindowExcludeClause <- 'EXCLUDE' WindowExcludeElement\n"
	"WindowExcludeElement <- ('CURRENT' 'ROW') / 'GROUP' / 'TIES' / ('NO' 'OTHERS')\n"
	"OverClause <- 'OVER' WindowFrame\n"
	"WindowFrame <- WindowFrameDefinition / Identifier / Parens(Identifier)\n"
	"WindowFrameDefinition <- Parens(BaseWindowName? WindowFrameContents) / Parens(WindowFrameContents)\n"
	"WindowFrameContents <- WindowPartition? OrderByClause? FrameClause?\n"
	"BaseWindowName <- Identifier\n"
	"WindowPartition <- 'PARTITION' 'BY' List(Expression)\n"
	"PrefixExpression <- PrefixOperator Expression\n"
	"PrefixOperator <- 'NOT' / '-' / '+' / '~'\n"
	"ListExpression <- 'ARRAY'? (BoundedListExpression / SelectStatement)\n"
	"BoundedListExpression <- '[' List(Expression)? ']'\n"
	"StructExpression <- '{' List(StructField)? '}'\n"
	"StructField <- Expression ':' Expression\n"
	"MapExpression <- 'MAP' StructExpression\n"
	"GroupingExpression <- GroupingOrGroupingId Parens(List(Expression))\n"
	"GroupingOrGroupingId <- 'GROUPING' / 'GROUPING_ID'\n"
	"Parameter <- '?' / NumberedParameter / ColLabelParameter\n"
	"NumberedParameter <- '$' NumberLiteral\n"
	"ColLabelParameter <- '$' ColLabel\n"
	"PositionalExpression <- '#' NumberLiteral\n"
	"DefaultExpression <- 'DEFAULT'\n"
	"ListComprehensionExpression <- '[' Expression 'FOR' List(Expression) ListComprehensionFilter? ']'\n"
	"ListComprehensionFilter <- 'F' Expression\n"
	"SingleExpression <-\n"
	"	LiteralExpression /\n"
	"	Parameter /\n"
	"    SubqueryExpression /\n"
	"    SpecialFunctionExpression /\n"
	"    ParenthesisExpression /\n"
	"    IntervalLiteral /\n"
	"    TypeLiteral /\n"
	"    CaseExpression /\n"
	"    StarExpression /\n"
	"    CastExpression /\n"
	"    GroupingExpression /\n"
	"    MapExpression /\n"
	"    FunctionExpression /\n"
	"    ColumnReference /\n"
	"    PrefixExpression /\n"
	"    ListComprehensionExpression /\n"
	"    ListExpression /\n"
	"    StructExpression /\n"
	"    PositionalExpression /\n"
	"    DefaultExpression\n"
	"OperatorLiteral <- <[\\+\\-\\*\\/\\%\\^\\<\\>\\=\\~\\!\\@\\&\\|\\`]+>\n"
	"LikeOperator <- 'NOT'? LikeOrSimilarTo\n"
	"LikeOrSimilarTo <- 'LIKE' / 'LIKE' / 'GLOB' / ('SIMILAR' 'TO')\n"
	"InOperator <- 'NOT'? 'N'\n"
	"IsOperator <- 'S' 'NOT'? DistinctFrom?\n"
	"DistinctFrom <- 'DISTINCT' 'FROM'\n"
	"ConjunctionOperator <- 'OR' / 'AND'\n"
	"ComparisonOperator <- '=' / '<=' / '>=' / '<' / '>' / '<>' / '!=' / '=='\n"
	"BetweenOperator <- 'NOT'? 'BETWEEN'\n"
	"CollateOperator <- 'COLLATE'\n"
	"LambdaOperator <- '->'\n"
	"EscapeOperator <- 'ESCAPE'\n"
	"AtTimeZoneOperator <- 'AT' 'TIME' 'ZONE'\n"
	"PostfixOperator <- '!'\n"
	"AnyAllOperator <- ComparisonOperator AnyOrAll\n"
	"AnyOrAll <- 'ANY' / 'ALL'\n"
	"Operator <-\n"
	"	AnyAllOperator /\n"
	"    ConjunctionOperator /\n"
	"    LikeOperator /\n"
	"    InOperator /\n"
	"    IsOperator /\n"
	"    BetweenOperator /\n"
	"    CollateOperator /\n"
	"    LambdaOperator /\n"
	"    EscapeOperator /\n"
	"    AtTimeZoneOperator /\n"
	"    OperatorLiteral\n"
	"CastOperator <- '::' Type\n"
	"DotOperator <- '.' (FunctionExpression / ColLabel)\n"
	"NotNull <- 'NOT' 'NULL'\n"
	"Indirection <- CastOperator / DotOperator / SliceExpression / NotNull / PostfixOperator\n"
	"BaseExpression <- SingleExpression Indirection*\n"
	"Expression <- BaseExpression RecursiveExpression*\n"
	"RecursiveExpression <- (Operator Expression)\n"
	"SliceExpression <- '[' SliceBound ']'\n"
	"SliceBound <- Expression? (':' (Expression / '-')?)? (':' Expression?)?\n"
	"SpecialFunctionExpression <- CoalesceExpression / UnpackExpression / ColumnsExpression / ExtractExpression / LambdaExpression / NullIfExpression / PositionExpression / RowExpression / SubstringExpression / TrimExpression\n"
	"CoalesceExpression <- 'COALESCE' Parens(List(Expression))\n"
	"UnpackExpression <- 'UNPACK' Parens(Expression)\n"
	"ColumnsExpression <- '*'? 'COLUMNS' Parens(Expression)\n"
	"ExtractExpression <- 'EXTRACT' Parens(Expression 'FROM' Expression)\n"
	"LambdaExpression <- 'LAMBDA' List(ColIdOrString) ':' Expression\n"
	"NullIfExpression <- 'NULLIF' Parens(Expression ',' Expression)\n"
	"PositionExpression <- 'POSITION' Parens(Expression)\n"
	"RowExpression <- 'ROW' Parens(List(Expression))\n"
	"SubstringExpression <- 'SUBSTRING' Parens(SubstringParameters / List(Expression))\n"
	"SubstringParameters <- Expression 'FROM' NumberLiteral 'FOR' NumberLiteral\n"
	"TrimExpression <- 'TRIM' Parens(TrimDirection? TrimSource? List(Expression))\n"
	"TrimDirection <- 'BOTH' / 'LEADING' / 'TRAILING'\n"
	"TrimSource <- Expression? 'FROM'\n"
	"ExecuteStatement <- 'EXECUTE' Identifier TableFunctionArguments?\n"
	"CreateSecretStmt <- 'SECRET' IfNotExists? SecretName? SecretStorageSpecifier? Parens(GenericCopyOptionList)\n"
	"SecretStorageSpecifier <- 'IN' Identifier\n"
	"CreateViewStmt <- 'RECURSIVE'? 'VIEW' IfNotExists? QualifiedName InsertColumnList? 'AS' SelectStatement\n"
	"DescribeStatement <- ShowSelect / ShowAllTables / ShowQualifiedName\n"
	"ShowSelect <- ShowOrDescribeOrSummarize SelectStatement\n"
	"ShowAllTables <- ShowOrDescribe 'ALL' 'TABLES'\n"
	"ShowQualifiedName <- ShowOrDescribeOrSummarize (BaseTableName / StringLiteral)?\n"
	"ShowOrDescribeOrSummarize <- ShowOrDescribe / 'SUMMARIZE'\n"
	"ShowOrDescribe <- 'SHOW' / 'DESCRIBE' / 'DESC'\n"
	"VacuumStatement <- 'VACUUM' (VacuumLegacyOptions AnalyzeStatement / VacuumLegacyOptions QualifiedTarget / VacuumLegacyOptions / VacuumParensOptions QualifiedTarget?)?\n"
	"VacuumLegacyOptions <- OptFull OptFreeze OptVerbose\n"
	"VacuumParensOptions <- Parens(List(VacuumOption))\n"
	"VacuumOption <- 'ANALYZE' / 'VERBOSE' / 'FREEZE' / 'FULL' / Identifier\n"
	"OptFull <- 'FULL'?\n"
	"OptFreeze <- 'FREEZE'?\n"
	"OptVerbose <- 'VERBOSE'?\n"
	"QualifiedTarget <- QualifiedName OptNameList\n"
	"OptNameList <- Parens(List(Name))?\n"
	"MergeIntoStatement <- WithClause? 'MERGE' 'NTO' TargetOptAlias MergeIntoUsingClause MergeMatch* ReturningClause?\n"
	"MergeIntoUsingClause <- 'USING' TableRef JoinQualifier\n"
	"MergeMatch <- MatchedClause / NotMatchedClause\n"
	"MatchedClause <- 'WHEN' 'MATCHED' AndExpression? 'THEN' MatchedClauseAction\n"
	"MatchedClauseAction <- UpdateMatchClause / DeleteMatchClause / InsertMatchClause / DoNothingMatchClause / ErrorMatchClause\n"
	"UpdateMatchClause <- 'UPDATE' (UpdateMatchSetClause / ByNameOrPosition?)\n"
	"DeleteMatchClause <- 'DELETE'\n"
	"InsertMatchClause <- 'NSERT' (InsertValuesList / DefaultValues / InsertByNameOrPosition)?\n"
	"InsertByNameOrPosition <- ByNameOrPosition? '*'?\n"
	"InsertValuesList <- InsertColumnList? 'VALUES' Parens(List(Expression))\n"
	"DoNothingMatchClause <- 'DO' 'NOTHING'\n"
	"ErrorMatchClause <- 'ERROR' Expression?\n"
	"UpdateMatchSetClause <- 'SET' (UpdateSetClause / '*')\n"
	"AndExpression <- 'AND' Expression\n"
	"NotMatchedClause <- 'WHEN' 'NOT' 'MATCHED' BySourceOrTarget? AndExpression? 'THEN' MatchedClauseAction\n"
	"BySourceOrTarget <- 'BY' ('SOURCE' / 'TARGET')\n"
	"PragmaStatement <- 'PRAGMA' (PragmaAssign / PragmaFunction)\n"
	"PragmaAssign <- SettingName '=' VariableList\n"
	"PragmaFunction <- PragmaName PragmaParameters?\n"
	"PragmaParameters <- List(Expression)\n"
	"DeallocateStatement <- 'DEALLOCATE' 'PREPARE'? Identifier\n"
	"PrepareStatement <- 'PREPARE' Identifier TypeList? 'AS' Statement\n"
	"TypeList <- Parens(List(Type))\n"
	"CreateStatement <- 'CREATE' OrReplace? Temporary? (CreateTableStmt / CreateMacroStmt / CreateSequenceStmt / CreateTypeStmt / CreateSchemaStmt / CreateViewStmt / CreateIndexStmt / CreateSecretStmt)\n"
	"OrReplace <- 'OR' 'REPLACE'\n"
	"Temporary <- 'TEMP' / 'TEMPORARY' / 'PERSISTENT'\n"
	"CreateTableStmt <- 'TABLE' IfNotExists? QualifiedName (CreateTableAs / CreateColumnList) CommitAction?\n"
	"CreateTableAs <- IdentifierList? 'AS' SelectStatement WithData?\n"
	"WithData <- 'WITH' 'NO'? 'DATA'\n"
	"IdentifierList <- Parens(List(Identifier))\n"
	"CreateColumnList <- Parens(CreateTableColumnList)\n"
	"IfNotExists <- 'F' 'NOT' 'EXISTS'\n"
	"QualifiedName <- CatalogReservedSchemaIdentifier / SchemaReservedIdentifierOrStringLiteral / IdentifierOrStringLiteral\n"
	"SchemaReservedIdentifierOrStringLiteral <- SchemaQualification ReservedIdentifierOrStringLiteral\n"
	"CatalogReservedSchemaIdentifier <- CatalogQualification ReservedSchemaQualification ReservedIdentifierOrStringLiteral\n"
	"IdentifierOrStringLiteral <- Identifier / StringLiteral\n"
	"ReservedIdentifierOrStringLiteral <- ReservedIdentifier / StringLiteral\n"
	"CatalogQualification <- CatalogName '.'\n"
	"SchemaQualification <- SchemaName '.'\n"
	"ReservedSchemaQualification <- ReservedSchemaName '.'\n"
	"TableQualification <- TableName '.'\n"
	"ReservedTableQualification <- ReservedTableName '.'\n"
	"CreateTableColumnList <- List(CreateTableColumnElement)\n"
	"CreateTableColumnElement <- ColumnDefinition / TopLevelConstraint\n"
	"ColumnDefinition <- DottedIdentifier TypeOrGenerated ColumnConstraint*\n"
	"TypeOrGenerated <- Type? GeneratedColumn?\n"
	"ColumnConstraint <- NotNullConstraint / UniqueConstraint / PrimaryKeyConstraint / DefaultValue / CheckConstraint / ForeignKeyConstraint / ColumnCollation / ColumnCompression\n"
	"NotNullConstraint <- 'NOT'? 'NULL'\n"
	"UniqueConstraint <- 'UNIQUE'\n"
	"PrimaryKeyConstraint <- 'PRIMARY' 'KEY'\n"
	"DefaultValue <- 'DEFAULT' Expression\n"
	"CheckConstraint <- 'CHECK' Parens(Expression)\n"
	"ForeignKeyConstraint <- 'REFERENCES' BaseTableName Parens(ColumnList)? KeyActions?\n"
	"ColumnCollation <- 'COLLATE' Expression\n"
	"ColumnCompression <- 'USING' 'COMPRESSION' ColIdOrString\n"
	"KeyActions <- UpdateAction? DeleteAction?\n"
	"UpdateAction <- 'ON' 'UPDATE' KeyAction\n"
	"DeleteAction <- 'ON' 'DELETE' KeyAction\n"
	"KeyAction <- ('NO' 'ACTION') / 'RESTRICT' / 'CASCADE' / ('SET' 'NULL') / ('SET' 'DEFAULT')\n"
	"TopLevelConstraint <- ConstraintNameClause? TopLevelConstraintList\n"
	"TopLevelConstraintList <- TopPrimaryKeyConstraint / CheckConstraint / TopUniqueConstraint / TopForeignKeyConstraint\n"
	"ConstraintNameClause <- 'CONSTRAINT' Identifier\n"
	"TopPrimaryKeyConstraint <- 'PRIMARY' 'KEY' ColumnIdList\n"
	"TopUniqueConstraint <- 'UNIQUE' ColumnIdList\n"
	"TopForeignKeyConstraint <- 'FOREIGN' 'KEY' ColumnIdList ForeignKeyConstraint\n"
	"ColumnIdList <- Parens(List(ColId))\n"
	"PlainIdentifier <- !ReservedKeyword <[a-z_]i[a-z0-9_]i*>\n"
	"QuotedIdentifier <- '\"' [^\"]* '\"'\n"
	"DottedIdentifier <- Identifier ('.' Identifier)*\n"
	"Identifier <- QuotedIdentifier / PlainIdentifier\n"
	"ColId <- UnreservedKeyword / ColumnNameKeyword / Identifier\n"
	"ColIdOrString <- ColId / StringLiteral\n"
	"FuncName <- UnreservedKeyword / FuncNameKeyword / Identifier\n"
	"TypeFuncName <- UnreservedKeyword / TypeNameKeyword / FuncNameKeyword / Identifier\n"
	"TypeName <- UnreservedKeyword / TypeNameKeyword / Identifier\n"
	"ColLabel <- ReservedKeyword / UnreservedKeyword / ColumnNameKeyword / FuncNameKeyword / TypeNameKeyword / Identifier\n"
	"ColLabelOrString <- ColLabel / StringLiteral\n"
	"GeneratedColumn <- Generated? 'AS' Parens(Expression) GeneratedColumnType?\n"
	"Generated <- 'GENERATED' AlwaysOrByDefault?\n"
	"AlwaysOrByDefault <- 'ALWAYS' / ('BY' 'DEFAULT')\n"
	"GeneratedColumnType <- 'VIRTUAL' / 'STORED'\n"
	"CommitAction <- 'ON' 'COMMIT' 'PRESERVE' 'ROWS'\n"
	"CreateIndexStmt <- Unique? 'NDEX' IfNotExists? IndexName? 'ON' BaseTableName IndexType? Parens(List(IndexElement)) WithList?\n"
	"WithList <- 'WITH' Parens(List(RelOption)) / Oids\n"
	"Oids <- ('WITH' / 'WITHOUT') 'OIDS'\n"
	"IndexElement <- Expression DescOrAsc? NullsFirstOrLast?\n"
	"Unique <- 'UNIQUE'\n"
	"IndexType <- 'USING' Identifier\n"
	"RelOption <- ColLabel ('.' ColLabel)* ('=' DefArg)?\n"
	"DefArg <- FuncType / ReservedKeyword / StringLiteral / NumberLiteral / 'NONE'\n"
	"FuncType <- Type / ('SETOF'? TypeFuncName '%' 'TYPE')\n"
	"LoadStatement <- 'LOAD' ColIdOrString\n"
	"InstallStatement <- 'FORCE'? 'NSTALL' Identifier FromSource? VersionNumber?\n"
	"FromSource <- 'FROM' (Identifier / StringLiteral)\n"
	"VersionNumber <- Identifier\n"
	"DropStatement <- 'DROP' DropEntries DropBehavior?\n"
	"DropEntries <-\n"
	"	DropTable /\n"
	"	DropTableFunction /\n"
	"	DropFunction /\n"
	"	DropSchema /\n"
	"	DropIndex /\n"
	"	DropSequence /\n"
	"	DropCollation /\n"
	"	DropType /\n"
	"	DropSecret\n"
	"DropTable <- TableOrView IfExists? List(BaseTableName)\n"
	"DropTableFunction <- 'MACRO' 'TABLE' IfExists? List(TableFunctionName)\n"
	"DropFunction <- FunctionType IfExists? List(FunctionIdentifier)\n"
	"DropSchema <- 'SCHEMA' IfExists? List(QualifiedSchemaName)\n"
	"DropIndex <- 'NDEX' IfExists? List(QualifiedIndexName)\n"
	"QualifiedIndexName <- CatalogQualification? SchemaQualification? IndexName\n"
	"DropSequence <- 'SEQUENCE' IfExists? List(QualifiedSequenceName)\n"
	"DropCollation <- 'COLLATION' IfExists? List(CollationName)\n"
	"DropType <- 'TYPE' IfExists? List(QualifiedTypeName)\n"
	"DropSecret <- Temporary? 'SECRET' IfExists? SecretName DropSecretStorage?\n"
	"TableOrView <- 'TABLE' / 'VIEW' / ('MATERIALIZED' 'VIEW')\n"
	"FunctionType <- 'MACRO' / 'FUNCTION'\n"
	"DropBehavior <- 'CASCADE' / 'RESTRICT'\n"
	"IfExists <- 'F' 'EXISTS'\n"
	"QualifiedSchemaName <- CatalogQualification? SchemaName\n"
	"DropSecretStorage <- 'FROM' Identifier\n"
	"UpdateStatement <- WithClause? 'UPDATE' UpdateTarget UpdateSetClause FromClause? WhereClause? ReturningClause?\n"
	"UpdateTarget <- (BaseTableName 'SET') / (BaseTableName UpdateAlias? 'SET')\n"
	"UpdateAlias <- 'AS'? ColId\n"
	"UpdateSetClause <- List(UpdateSetElement) / (Parens(List(ColumnName)) '=' Expression)\n"
	"UpdateSetElement <- ColumnName '=' Expression\n"
	"InsertStatement <- WithClause? 'NSERT' OrAction? 'NTO' InsertTarget ByNameOrPosition? InsertColumnList? InsertValues OnConflictClause? ReturningClause?\n"
	"OrAction <- 'OR' 'REPLACE' / 'GNORE'\n"
	"ByNameOrPosition <- 'BY' 'NAME' / 'POSITION'\n"
	"InsertTarget <- BaseTableName InsertAlias?\n"
	"InsertAlias <- 'AS' Identifier\n"
	"ColumnList <- List(ColId)\n"
	"InsertColumnList <- Parens(ColumnList)\n"
	"InsertValues <- SelectStatement / DefaultValues\n"
	"DefaultValues <- 'DEFAULT' 'VALUES'\n"
	"OnConflictClause <- 'ON' 'CONFLICT' OnConflictTarget? OnConflictAction\n"
	"OnConflictTarget <- OnConflictExpressionTarget / OnConflictIndexTarget\n"
	"OnConflictExpressionTarget <- Parens(List(ColId)) WhereClause?\n"
	"OnConflictIndexTarget <- 'ON' 'CONSTRAINT' ConstraintName\n"
	"OnConflictAction <- OnConflictUpdate / OnConflictNothing\n"
	"OnConflictUpdate <- 'DO' 'UPDATE' 'SET' UpdateSetClause WhereClause?\n"
	"OnConflictNothing <- 'DO' 'NOTHING'\n"
	"ReturningClause <- 'RETURNING' TargetList\n"
	"CreateSchemaStmt <- 'SCHEMA' IfNotExists? QualifiedName\n"
	"SelectStatement <- SelectOrParens (SetopClause SelectStatement)* ResultModifiers\n"
	"SetopClause <- ('UNION' / 'EXCEPT' / 'NTERSECT') DistinctOrAll? ByName?\n"
	"ByName <- 'BY' 'NAME'\n"
	"SelectOrParens <- BaseSelect / Parens(SelectStatement)\n"
	"BaseSelect <- WithClause? (OptionalParensSimpleSelect / ValuesClause / DescribeStatement / TableStatement / PivotStatement / UnpivotStatement) ResultModifiers\n"
	"ResultModifiers <- OrderByClause? LimitClause? OffsetClause?\n"
	"TableStatement <- 'TABLE' BaseTableName\n"
	"OptionalParensSimpleSelect <- Parens(SimpleSelect) / SimpleSelect\n"
	"SimpleSelect <- SelectFrom WhereClause? GroupByClause? HavingClause? WindowClause? QualifyClause? SampleClause?\n"
	"SelectFrom <- (SelectClause FromClause?) / (FromClause SelectClause?)\n"
	"WithStatement <- ColIdOrString InsertColumnList? UsingKey? 'AS' Materialized? SubqueryReference\n"
	"UsingKey <- 'USING' 'KEY' Parens(List(ColId))\n"
	"Materialized <- 'NOT'? 'MATERIALIZED'\n"
	"WithClause <- 'WITH' Recursive? List(WithStatement)\n"
	"Recursive <- 'RECURSIVE'\n"
	"SelectClause <- 'SELECT' DistinctClause? TargetList\n"
	"TargetList <- List(AliasedExpression)\n"
	"ColumnAliases <- Parens(List(ColIdOrString))\n"
	"DistinctClause <- ('DISTINCT' DistinctOn?) / 'ALL'\n"
	"DistinctOn <- 'ON' Parens(List(Expression))\n"
	"InnerTableRef <- ValuesRef / TableFunction / TableSubquery / BaseTableRef / ParensTableRef\n"
	"TableRef <- InnerTableRef JoinOrPivot* TableAlias?\n"
	"TableSubquery <- Lateral? SubqueryReference TableAlias?\n"
	"BaseTableRef <- TableAliasColon? BaseTableName TableAlias? AtClause?\n"
	"TableAliasColon <- ColIdOrString ':'\n"
	"ValuesRef <- ValuesClause TableAlias?\n"
	"ParensTableRef <- TableAliasColon? Parens(TableRef)\n"
	"JoinOrPivot <- JoinClause / TablePivotClause / TableUnpivotClause\n"
	"TablePivotClause <- 'PIVOT' Parens(TargetList 'FOR' PivotValueLists GroupByClause?) TableAlias?\n"
	"TableUnpivotClause <- 'UNPIVOT' IncludeExcludeNulls? Parens(UnpivotHeader 'FOR' PivotValueLists) TableAlias?\n"
	"PivotHeader <- BaseExpression\n"
	"PivotValueLists <- PivotValueList PivotValueList*\n"
	"PivotValueList <- PivotHeader 'N' PivotTargetList\n"
	"PivotTargetList <- Identifier / Parens(TargetList)\n"
	"Lateral <- 'LATERAL'\n"
	"BaseTableName <- CatalogReservedSchemaTable / SchemaReservedTable / TableName\n"
	"SchemaReservedTable <- SchemaQualification ReservedTableName\n"
	"CatalogReservedSchemaTable <- CatalogQualification ReservedSchemaQualification ReservedTableName\n"
	"TableFunction <- TableFunctionLateralOpt / TableFunctionAliasColon\n"
	"TableFunctionLateralOpt <- Lateral? QualifiedTableFunction TableFunctionArguments TableAlias?\n"
	"TableFunctionAliasColon <- TableAliasColon QualifiedTableFunction TableFunctionArguments\n"
	"QualifiedTableFunction <- CatalogQualification? SchemaQualification? TableFunctionName\n"
	"TableFunctionArguments <- Parens(List(FunctionArgument)?)\n"
	"FunctionArgument <- NamedParameter / Expression\n"
	"NamedParameter <- TypeName NamedParameterAssignment Expression\n"
	"NamedParameterAssignment <- ':=' / '=>'\n"
	"TableAlias <- 'AS'? (Identifier / StringLiteral) ColumnAliases?\n"
	"AtClause <- 'AT' Parens(AtSpecifier)\n"
	"AtSpecifier <- AtUnit '=>' Expression\n"
	"AtUnit <- 'VERSION' / 'TIMESTAMP'\n"
	"JoinClause <- RegularJoinClause / JoinWithoutOnClause\n"
	"RegularJoinClause <- 'ASOF'? JoinType? 'JOIN' TableRef JoinQualifier\n"
	"JoinWithoutOnClause <- JoinPrefix 'JOIN' TableRef\n"
	"JoinQualifier <- OnClause / UsingClause\n"
	"OnClause <- 'ON' Expression\n"
	"UsingClause <- 'USING' Parens(List(ColumnName))\n"
	"OuterJoinType <- 'FULL' / 'LEFT' / 'RIGHT'\n"
	"JoinType <- (OuterJoinType 'OUTER'?) / 'SEMI' / 'ANTI' / 'NNER'\n"
	"JoinPrefix <- 'CROSS' / ('NATURAL' JoinType?) / 'POSITIONAL'\n"
	"FromClause <- 'FROM' List(TableRef)\n"
	"WhereClause <- 'WHERE' Expression\n"
	"GroupByClause <- 'GROUP' 'BY' GroupByExpressions\n"
	"HavingClause <- 'HAVING' Expression\n"
	"QualifyClause <- 'QUALIFY' Expression\n"
	"SampleClause <- (TableSample / UsingSample) SampleEntry\n"
	"UsingSample <- 'USING' 'SAMPLE'\n"
	"TableSample <- 'TABLESAMPLE'\n"
	"WindowClause <- 'WINDOW' List(WindowDefinition)\n"
	"WindowDefinition <- Identifier 'AS' WindowFrameDefinition\n"
	"SampleEntry <- SampleEntryFunction / SampleEntryCount\n"
	"SampleEntryCount <- SampleCount Parens(SampleProperties)?\n"
	"SampleEntryFunction <- SampleFunction? Parens(SampleCount) RepeatableSample?\n"
	"SampleFunction <- ColId\n"
	"SampleProperties <- ColId (',' NumberLiteral)?\n"
	"RepeatableSample <- 'REPEATABLE' Parens(NumberLiteral)\n"
	"SampleCount <- Expression SampleUnit?\n"
	"SampleUnit <- '%' / 'PERCENT' / 'ROWS'\n"
	"GroupByExpressions <- GroupByList / 'ALL'\n"
	"GroupByList <- List(GroupByExpression)\n"
	"GroupByExpression <- EmptyGroupingItem / CubeOrRollupClause / GroupingSetsClause / Expression\n"
	"EmptyGroupingItem <- '(' ')'\n"
	"CubeOrRollupClause <- CubeOrRollup Parens(List(Expression))\n"
	"CubeOrRollup <- 'CUBE' / 'ROLLUP'\n"
	"GroupingSetsClause <- 'GROUPING' 'SETS' Parens(GroupByList)\n"
	"SubqueryReference <- Parens(SelectStatement)\n"
	"OrderByExpression <- Expression DescOrAsc? NullsFirstOrLast?\n"
	"DescOrAsc <- 'DESC' / 'DESCENDING' / 'ASC' / 'ASCENDING'\n"
	"NullsFirstOrLast <- 'NULLS' 'FIRST' / 'LAST'\n"
	"OrderByClause <- 'ORDER' 'BY' OrderByExpressions\n"
	"OrderByExpressions <- List(OrderByExpression) / OrderByAll\n"
	"OrderByAll <- 'ALL' DescOrAsc? NullsFirstOrLast?\n"
	"LimitClause <- 'LIMIT' LimitValue\n"
	"OffsetClause <- 'OFFSET' LimitValue\n"
	"LimitValue <- 'ALL' / (NumberLiteral 'PERCENT') / (Expression '%'?)\n"
	"AliasedExpression <- (ColId ':' Expression) / (Expression 'AS' ColLabelOrString) / (Expression Identifier?)\n"
	"ValuesClause <- 'VALUES' List(ValuesExpressions)\n"
	"ValuesExpressions <- Parens(List(Expression))\n"
	"TransactionStatement <- BeginTransaction / RollbackTransaction / CommitTransaction\n"
	"BeginTransaction <- StartOrBegin Transaction? ReadOrWrite?\n"
	"RollbackTransaction <- AbortOrRollback Transaction?\n"
	"CommitTransaction <- CommitOrEnd Transaction?\n"
	"StartOrBegin <- 'START' / 'BEGIN'\n"
	"Transaction <- 'WORK' / 'TRANSACTION'\n"
	"ReadOrWrite <- 'READ' ('ONLY' / 'WRITE')\n"
	"AbortOrRollback <- 'ABORT' / 'ROLLBACK'\n"
	"CommitOrEnd <- 'COMMIT' / 'END'\n"
	"DeleteStatement <- WithClause? 'DELETE' 'FROM' TargetOptAlias DeleteUsingClause? WhereClause? ReturningClause?\n"
	"TruncateStatement <- 'TRUNCATE' 'TABLE'? BaseTableName\n"
	"TargetOptAlias <- BaseTableName 'AS'? ColId?\n"
	"DeleteUsingClause <- 'USING' List(TableRef)\n"
	"CreateTypeStmt <- 'TYPE' IfNotExists? QualifiedName 'AS' CreateType\n"
	"CreateType <- ('ENUM' Parens(SelectStatement)) /\n"
	"              ('ENUM' Parens(List(StringLiteral))) /\n"
	"              Type\n"
	"SetStatement <- 'SET' (StandardAssignment / SetTimeZone)\n"
	"StandardAssignment <- (SetVariable / SetSetting) SetAssignment\n"
	"SetTimeZone <- 'TIME' 'ZONE' Expression\n"
	"SetSetting <- SettingScope? SettingName\n"
	"SetVariable <- 'VARIABLE' Identifier\n"
	"SettingScope <- 'LOCAL' / 'SESSION' / 'GLOBAL'\n"
	"SetAssignment <- VariableAssign VariableList\n"
	"VariableAssign <- '=' / 'TO'\n"
	"VariableList <- List(Expression)\n"
	"ResetStatement <- 'RESET' (SetVariable / SetSetting)\n"
	"ExportStatement <- 'EXPORT' 'DATABASE' ExportSource? StringLiteral Parens(GenericCopyOptionList)?\n"
	"ExportSource <- CatalogName 'TO'\n"
	"ImportStatement <- 'MPORT' 'DATABASE' StringLiteral\n"
	"CheckpointStatement <- 'FORCE'? 'CHECKPOINT' CatalogName?\n"
	"CopyStatement <- 'COPY' (CopyTable / CopySelect / CopyFromDatabase)\n"
	"CopyTable <- BaseTableName InsertColumnList? FromOrTo CopyFileName CopyOptions?\n"
	"FromOrTo <- 'FROM' / 'TO'\n"
	"CopySelect <- Parens(SelectStatement) 'TO' CopyFileName CopyOptions?\n"
	"CopyFileName <- StringLiteral / Identifier / (Identifier '.' ColId)\n"
	"CopyOptions <- 'WITH'? (Parens(GenericCopyOptionList) / (SpecializedOptions*))\n"
	"SpecializedOptions <-\n"
	"	'BINARY' / 'FREEZE' / 'OIDS' / 'CSV' / 'HEADER' /\n"
	"	SpecializedStringOption /\n"
	"	('ENCODING' StringLiteral) /\n"
	"	('FORCE' 'QUOTE' StarOrColumnList) /\n"
	"	('PARTITION' 'BY' StarOrColumnList) /\n"
	"	('FORCE' 'NOT'? 'NULL' ColumnList)\n"
	"SpecializedStringOption <- ('DELIMITER' / 'NULL' / 'QUOTE' / 'ESCAPE') 'AS'? StringLiteral\n"
	"StarOrColumnList <- '*' / ColumnList\n"
	"GenericCopyOptionList <- List(GenericCopyOption)\n"
	"GenericCopyOption <- GenericCopyOptionName Expression?\n"
	"# FIXME: should not need to hard-code options here\n"
	"GenericCopyOptionName <- 'ARRAY' / 'NULL' / 'ANALYZE' / CopyOptionName\n"
	"CopyFromDatabase <- 'FROM' 'DATABASE' ColId 'TO' ColId CopyDatabaseFlag?\n"
	"CopyDatabaseFlag <- Parens(SchemaOrData)\n"
	"SchemaOrData <- 'SCHEMA' / 'DATA'\n"
	"AlterStatement <- 'ALTER' AlterOptions\n"
	"AlterOptions <- AlterTableStmt / AlterViewStmt / AlterSequenceStmt\n"
	"AlterTableStmt <- 'TABLE' IfExists? BaseTableName AlterTableOptions\n"
	"AlterTableOptions <- AddColumn / DropColumn / AlterColumn / AddConstraint / ChangeNullability / RenameColumn / RenameAlter / SetPartitionedBy / ResetPartitionedBy / SetSortedBy / ResetSortedBy\n"
	"AddConstraint <- 'ADD' TopLevelConstraint\n"
	"AddColumn <- 'ADD' 'COLUMN'? IfNotExists? ColumnDefinition\n"
	"DropColumn <- 'DROP' 'COLUMN'? IfExists? NestedColumnName DropBehavior?\n"
	"AlterColumn <- 'ALTER' 'COLUMN'? NestedColumnName AlterColumnEntry\n"
	"RenameColumn <- 'RENAME' 'COLUMN'? NestedColumnName 'TO' Identifier\n"
	"NestedColumnName <- (Identifier '.')* ColumnName\n"
	"RenameAlter <- 'RENAME' 'TO' Identifier\n"
	"SetPartitionedBy <- 'SET' 'PARTITIONED' 'BY' Parens(List(Expression))\n"
	"ResetPartitionedBy <- 'RESET' 'PARTITIONED' 'BY'\n"
	"SetSortedBy <- 'SET' 'SORTED' 'BY' OrderByExpressions\n"
	"ResetSortedBy <- 'RESET' 'SORTED' 'BY'\n"
	"AlterColumnEntry <- AddOrDropDefault / ChangeNullability / AlterType\n"
	"AddOrDropDefault <- AddDefault / DropDefault\n"
	"AddDefault <- 'SET' 'DEFAULT' Expression\n"
	"DropDefault <- 'DROP' 'DEFAULT'\n"
	"ChangeNullability <- ('DROP' / 'SET') 'NOT' 'NULL'\n"
	"AlterType <- SetData? 'TYPE' Type? UsingExpression?\n"
	"SetData <- 'SET' 'DATA'?\n"
	"UsingExpression <- 'USING' Expression\n"
	"AlterViewStmt <- 'VIEW' IfExists? BaseTableName RenameAlter\n"
	"AlterSequenceStmt <- 'SEQUENCE' IfExists? QualifiedSequenceName AlterSequenceOptions\n"
	"QualifiedSequenceName <- CatalogQualification? SchemaQualification? SequenceName\n"
	"AlterSequenceOptions <- RenameAlter / SetSequenceOption\n"
	"SetSequenceOption <- List(SequenceOption)\n"
	"CreateSequenceStmt <- 'SEQUENCE' IfNotExists? QualifiedName SequenceOption*\n"
	"SequenceOption <-\n"
	"	SeqSetCycle /\n"
	"	SeqSetIncrement /\n"
	"	SeqSetMinMax /\n"
	"	SeqNoMinMax /\n"
	"	SeqStartWith /\n"
	"	SeqOwnedBy\n"
	"SeqSetCycle <- 'NO'? 'CYCLE'\n"
	"SeqSetIncrement <- 'NCREMENT' 'BY'? Expression\n"
	"SeqSetMinMax <- SeqMinOrMax Expression\n"
	"SeqNoMinMax <- 'NO' SeqMinOrMax\n"
	"SeqStartWith <- 'START' 'WITH'? Expression\n"
	"SeqOwnedBy <- 'OWNED' 'BY' QualifiedName\n"
	"SeqMinOrMax <- 'MINVALUE' / 'MAXVALUE'\n"
	"Statement <-\n"
	"	CreateStatement /\n"
	"	SelectStatement /\n"
	"	SetStatement /\n"
	"	PragmaStatement /\n"
	"	CallStatement /\n"
	"	InsertStatement /\n"
	"	DropStatement /\n"
	"	CopyStatement /\n"
	"	ExplainStatement /\n"
	"	UpdateStatement /\n"
	"	PrepareStatement /\n"
	"	ExecuteStatement /\n"
	"	AlterStatement /\n"
	"	TransactionStatement /\n"
	"	DeleteStatement /\n"
	"	AttachStatement /\n"
	"	UseStatement /\n"
	"	DetachStatement /\n"
	"	CheckpointStatement /\n"
	"	VacuumStatement /\n"
	"	ResetStatement /\n"
	"	ExportStatement /\n"
	"	ImportStatement /\n"
	"	CommentStatement /\n"
	"	DeallocateStatement /\n"
	"	TruncateStatement /\n"
	"	LoadStatement /\n"
	"	InstallStatement /\n"
	"	AnalyzeStatement /\n"
	"	MergeIntoStatement\n"
	"CatalogName <- Identifier\n"
	"SchemaName <- Identifier\n"
	"ReservedSchemaName <- Identifier\n"
	"TableName <- Identifier\n"
	"ReservedTableName <- Identifier\n"
	"ReservedIdentifier <- Identifier\n"
	"ColumnName <- Identifier\n"
	"ReservedColumnName <- Identifier\n"
	"IndexName <- Identifier\n"
	"SettingName <- Identifier\n"
	"PragmaName <- Identifier\n"
	"FunctionName <- Identifier\n"
	"ReservedFunctionName <- Identifier\n"
	"TableFunctionName <- Identifier\n"
	"ConstraintName <- ColIdOrString\n"
	"SequenceName <- Identifier\n"
	"CollationName <- Identifier\n"
	"CopyOptionName <- ColLabel\n"
	"SecretName <- ColId\n"
	"NumberLiteral <- < [+-]?[0-9]*([.][0-9]*)? >\n"
	"StringLiteral <- '\\'' [^\\']* '\\''\n"
	"Type <- (TimeType / IntervalType / BitType / RowType / MapType / UnionType / NumericType / SimpleType) ArrayBounds*\n"
	"SimpleType <- (QualifiedTypeName / CharacterType) TypeModifiers?\n"
	"CharacterType <- ('CHARACTER' 'VARYING'?) /\n"
	"                 ('CHAR' 'VARYING'?) /\n"
	"                 ('NATIONAL' 'CHARACTER' 'VARYING'?) /\n"
	"                 ('NATIONAL' 'CHAR' 'VARYING'?) /\n"
	"                 ('NCHAR' 'VARYING'?) /\n"
	"                 'VARCHAR'\n"
	"IntervalType <- ('NTERVAL' Interval?) / ('NTERVAL' Parens(NumberLiteral))\n"
	"YearKeyword         <- 'YEAR' / 'YEARS'\n"
	"MonthKeyword        <- 'MONTH' / 'MONTHS'\n"
	"DayKeyword          <- 'DAY' / 'DAYS'\n"
	"HourKeyword         <- 'HOUR' / 'HOURS'\n"
	"MinuteKeyword       <- 'MINUTE' / 'MINUTES'\n"
	"SecondKeyword       <- 'SECOND' / 'SECONDS'\n"
	"MillisecondKeyword  <- 'MILLISECOND' / 'MILLISECONDS'\n"
	"MicrosecondKeyword  <- 'MICROSECOND' / 'MICROSECONDS'\n"
	"WeekKeyword         <- 'WEEK' / 'WEEKS'\n"
	"QuarterKeyword      <- 'QUARTER' / 'QUARTERS'\n"
	"DecadeKeyword       <- 'DECADE' / 'DECADES'\n"
	"CenturyKeyword      <- 'CENTURY' / 'CENTURIES'\n"
	"MillenniumKeyword   <- 'MILLENNIUM' / 'MILLENNIA'\n"
	"Interval <- YearKeyword /\n"
	"    MonthKeyword /\n"
	"    DayKeyword /\n"
	"    HourKeyword /\n"
	"    MinuteKeyword /\n"
	"    SecondKeyword /\n"
	"    MillisecondKeyword /\n"
	"    MicrosecondKeyword /\n"
	"    WeekKeyword /\n"
	"    QuarterKeyword /\n"
	"    DecadeKeyword /\n"
	"    CenturyKeyword /\n"
	"    MillenniumKeyword /\n"
	"    (YearKeyword 'TO' MonthKeyword) /\n"
	"    (DayKeyword 'TO' HourKeyword) /\n"
	"    (DayKeyword 'TO' MinuteKeyword) /\n"
	"    (DayKeyword 'TO' SecondKeyword) /\n"
	"    (HourKeyword 'TO' MinuteKeyword) /\n"
	"    (HourKeyword 'TO' SecondKeyword) /\n"
	"    (MinuteKeyword 'TO' SecondKeyword)\n"
	"BitType <- 'BIT' 'VARYING'? Parens(List(Expression))?\n"
	"NumericType <- 'NT' /\n"
	"               'NTEGER' /\n"
	"               'SMALLINT' /\n"
	"               'BIGINT' /\n"
	"               'REAL' /\n"
	"               'BOOLEAN' /\n"
	"               ('FLOAT' Parens(NumberLiteral)?) /\n"
	"               ('DOUBLE' 'PRECISION') /\n"
	"               ('DECIMAL' TypeModifiers?) /\n"
	"               ('DEC' TypeModifiers?) /\n"
	"               ('NUMERIC' TypeModifiers?)\n"
	"QualifiedTypeName <- CatalogQualification? SchemaQualification? TypeName\n"
	"TypeModifiers <- Parens(List(Expression)?)\n"
	"RowType <- RowOrStruct Parens(List(ColIdType))\n"
	"UnionType <- 'UNION' Parens(List(ColIdType))\n"
	"MapType <- 'MAP' Parens(List(Type))\n"
	"ColIdType <- ColId Type\n"
	"ArrayBounds <- ('[' NumberLiteral? ']') / 'ARRAY'\n"
	"TimeType <- TimeOrTimestamp TypeModifiers? TimeZone?\n"
	"TimeOrTimestamp <- 'TIME' / 'TIMESTAMP'\n"
	"TimeZone <- WithOrWithout 'TIME' 'ZONE'\n"
	"WithOrWithout <- 'WITH' / 'WITHOUT'\n"
	"RowOrStruct <- 'ROW' / 'STRUCT'\n"
	"# internal definitions\n"
	"%whitespace <- [ \\t\\n\\r]*\n"
	"List(D) <- D (',' D)* ','?\n"
	"Parens(D) <- '(' D ')'\n"
	"ExplainStatement <- 'EXPLAIN' 'ANALYZE'? ExplainOptions? Statement\n"
	"ExplainOptions <- Parens(GenericCopyOptionList)\n"
	"AnalyzeStatement <- 'ANALYZE' 'VERBOSE'? AnalyzeTarget?\n"
	"AnalyzeTarget <- QualifiedName Parens(List(Name))?\n"
	"Name <- ColId ('.' ColLabel)*\n"
	"CreateMacroStmt <- MacroOrFunction IfNotExists? QualifiedName List(MacroDefinition)\n"
	"MacroOrFunction <- 'MACRO' / 'FUNCTION'\n"
	"MacroDefinition <- Parens(MacroParameters?) 'AS' (TableMacroDefinition / ScalarMacroDefinition)\n"
	"MacroParameters <- List(MacroParameter)\n"
	"MacroParameter <- NamedParameter / TypeFuncName\n"
	"ScalarMacroDefinition <- Expression\n"
	"TableMacroDefinition <- 'TABLE' SelectStatement\n"
	"CommentStatement <- 'COMMENT' 'ON' CommentOnType ColumnReference 'S' CommentValue\n"
	"CommentOnType <- 'TABLE' / 'SEQUENCE' / 'FUNCTION' / ('MACRO' 'TABLE'?) / 'VIEW' / 'DATABASE' / 'NDEX' / 'SCHEMA' / 'TYPE' / 'COLUMN'\n"
	"CommentValue <- 'NULL' / StringLiteral\n"
	"AttachStatement <- 'ATTACH' OrReplace? IfNotExists? Database? DatabasePath AttachAlias? AttachOptions?\n"
	"Database <- 'DATABASE'\n"
	"DatabasePath <- StringLiteral\n"
	"AttachAlias <- 'AS' ColId\n"
	"AttachOptions <- Parens(GenericCopyOptionList)\n"
	"DetachStatement <- 'DETACH' Database? IfExists? CatalogName\n"
	"UseStatement <- 'USE' UseTarget\n"
	"UseTarget <- (CatalogName '.' ReservedSchemaName) / SchemaName / CatalogName\n"
	"CallStatement <- 'CALL' TableFunctionName TableFunctionArguments\n"

};

} // namespace duckdb
